<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <script>
    if (location.protocol.startsWith('http') && location.hostname !== 'localhost') {
        const domain = location.hostname.replace(/^www\./, '');
        if (location.protocol !== 'https:' || location.hostname !== domain) {
            location.replace('https://' + domain + location.pathname + location.search + location.hash);
        }
    }
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
    <meta name="format-detection" content="telephone=no,address=no,email=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <link rel="manifest" id="app-manifest" href="">
    <script>
        (function () {
            const REPO = 'sf-speed-alerts';
            const path = location.pathname.replace(/\/+$/, '');
            const onRepo = location.hostname.endsWith('github.io') && path.startsWith('/' + REPO);
            let base = onRepo ? ('/' + REPO) : '';
            if (!base) {
                const parts = location.pathname.split('/');
                const idx = parts.lastIndexOf(REPO);
                if (idx > -1) base = '/' + parts.slice(1, idx + 1).join('/');
            }
            window.BASE = base;
            window.DATA_BASE = `${base}/data`;
            window.DEV = /[?&]dev=1\b/.test(location.search);
            const m = document.getElementById('app-manifest');
            if (m) m.setAttribute('href', `${base}/manifest.json`);
        })();
    </script>
    <script>
        (function setVH(){
            function apply(){
                var h = Math.round((window.visualViewport?.height || window.innerHeight));
                document.documentElement.style.setProperty('--vhpx', h + 'px');
            }
            apply();
            window.addEventListener('resize', apply, {passive:true});
            window.visualViewport && window.visualViewport.addEventListener('resize', apply, {passive:true});
            window.addEventListener('orientationchange', () => setTimeout(apply, 60), {passive:true});
        })();
    </script>
    <title>SpeedWarn — SF Speed Camera Alerts</title>
    <meta name="description" content="Free real-time speed camera alerts for San Francisco. GPS-powered, 33 camera locations, audio warnings. No tracking. 100% on-device.">
    <meta property="og:title" content="SpeedWarn — SF Speed Camera Alerts">
    <meta property="og:description" content="Free real-time speed camera alerts for San Francisco. 33 camera locations with audio warnings.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://speedwarn.com">
    <meta name="twitter:card" content="summary">
    <link rel="canonical" href="https://speedwarn.com">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script defer src="https://unpkg.com/kdbush@4.0.2/kdbush.min.js"></script>
    <script defer src="https://unpkg.com/geokdbush@4.0.2/geokdbush.min.js"></script>
    <link rel="preload" as="audio" href="images/audio/beep.mp3" type="audio/mpeg">
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #0a0a0a;
            --surface: #111;
            --surface-2: #1a1a1a;
            --border: #222;
            --text: #e8e8e8;
            --text-dim: #888;
            --accent: #fff;
            --red: #d62828;
            --green: #1a8754;
            --yellow: #b89b00;
            --vhpx: 100vh;
        }
        html, body {
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, system-ui, 'Helvetica Neue', Arial, sans-serif;
            font-weight: 500;
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: var(--vhpx);
        }

        /* --- HEADER --- */
        .header {
            padding: 20px 16px 0;
            text-align: center;
        }
        .header h1 {
            font-size: 28px;
            font-weight: 800;
            letter-spacing: -0.5px;
            color: var(--accent);
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        .header p {
            font-size: 14px;
            color: var(--text-dim);
            line-height: 1.4;
            max-width: 340px;
            margin: 0 auto;
        }

        /* --- MAIN CONTROLS --- */
        .controls {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .btn-start {
            display: block;
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-weight: 800;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            text-align: center;
            border: 2px solid var(--red);
            background: var(--red);
            color: #fff;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-start:active { opacity: 0.85; }
        .btn-start[data-state="on"] {
            background: var(--green);
            border-color: var(--green);
        }
        .btn-start[data-state="mute"] {
            background: var(--yellow);
            border-color: var(--yellow);
            color: #111;
        }
        .btn-row {
            display: flex;
            gap: 10px;
        }
        .btn-secondary {
            flex: 1;
            padding: 10px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            text-align: center;
            background: var(--surface-2);
            color: var(--text-dim);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: color 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-secondary:active { color: var(--accent); }

        /* --- STATUS BAR --- */
        .status-bar {
            padding: 0 16px;
            margin-bottom: 12px;
        }
        .status-inner {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-dim);
        }
        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--red);
            flex-shrink: 0;
        }
        .status-dot.active { background: var(--green); }

        /* --- MAP --- */
        .map-wrap {
            padding: 0 16px;
            flex: 1;
            min-height: 0;
        }
        #map {
            width: 100%;
            height: calc(var(--vhpx) * 0.48);
            min-height: 260px;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        .leaflet-container { background: var(--surface) !important; }

        /* --- CAMERA LIST --- */
        .camera-section {
            padding: 16px;
        }
        .camera-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .camera-header span {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .camera-header .arrow {
            font-size: 11px;
            color: var(--text-dim);
            transition: transform 0.2s;
        }
        .camera-header.open .arrow { transform: rotate(180deg); }
        .camera-list {
            max-height: 0;
            overflow-y: auto;
            transition: max-height 0.3s ease;
            border: 1px solid var(--border);
            border-top: none;
        }
        .camera-list.open {
            max-height: 240px;
        }
        .camera-list li {
            list-style: none;
            padding: 8px 12px;
            font-size: 13px;
            color: var(--text-dim);
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .camera-list li:last-child { border-bottom: none; }
        .camera-list li:active { color: var(--accent); background: var(--surface-2); }

        /* --- SPEED SIGN --- */
        .speed-sign {
            position: fixed;
            left: 50%;
            top: 12px;
            transform: translateX(-50%) translateY(-100px);
            z-index: 70;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }
        .speed-sign.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        .speed-sign .sign {
            background: #fff;
            color: #000;
            border: 4px solid #000;
            width: min(46vw, 240px);
            padding: 10px 14px 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        .speed-sign .label {
            font-weight: 800;
            letter-spacing: 0.06em;
            text-align: center;
            font-size: 13px;
            margin-bottom: 2px;
        }
        .speed-sign .value {
            font-weight: 900;
            text-align: center;
            font-size: clamp(48px, 14vw, 96px);
            line-height: 1;
        }
        .speed-sign .capsule {
            margin-top: 6px;
            text-align: center;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.04em;
            color: #111;
            background: #eee;
            padding: 3px 8px;
            display: none;
        }
        .speed-sign.unknown .capsule { display: inline-block; }

        /* --- FOOTER --- */
        footer {
            padding: 16px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            text-align: center;
            font-size: 11px;
            color: var(--text-dim);
        }
        footer a {
            color: var(--text-dim);
            text-decoration: none;
            border-bottom: 1px solid var(--border);
        }

        /* --- MODAL --- */
        .modal-backdrop {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        .modal-backdrop.show { display: flex; }
        .modal-box {
            background: var(--surface);
            border: 1px solid var(--border);
            max-width: min(92vw, 480px);
            max-height: 85vh;
            overflow-y: auto;
            padding: 24px;
        }
        .modal-box h2 {
            font-size: 18px;
            font-weight: 800;
            margin-bottom: 16px;
            text-transform: uppercase;
        }
        .modal-box p, .modal-box li {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-dim);
            margin-bottom: 10px;
        }
        .modal-box ul { padding-left: 18px; }
        .modal-box .warning {
            padding: 10px 12px;
            background: #2a2000;
            border: 1px solid #554400;
            color: #ddb700;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 16px;
        }
        .modal-check {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-dim);
        }
        .modal-check input[type="checkbox"] {
            margin-top: 2px;
            accent-color: var(--green);
        }
        .modal-btn {
            display: block;
            width: 100%;
            padding: 14px;
            font-size: 15px;
            font-weight: 800;
            text-transform: uppercase;
            text-align: center;
            background: var(--green);
            color: #fff;
            border: none;
            cursor: pointer;
            margin-top: 16px;
        }
        .modal-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .modal-close {
            float: right;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .modal-version {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 12px;
        }

        /* --- NAG --- */
        .nag-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 60;
        }
        .nag-wrap { position: relative; }
        .nag-img {
            max-width: min(90vw, 480px);
            display: block;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .nag-count {
            position: absolute;
            bottom: 10px;
            right: 14px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 800;
        }

        /* --- TOAST --- */
        .toast-container {
            position: fixed;
            bottom: calc(12px + env(safe-area-inset-bottom));
            left: 16px;
            right: 16px;
            z-index: 80;
        }
        .toast {
            display: none;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            align-items: center;
            gap: 12px;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .toast.show { display: flex; }
        .toast-text { flex: 1; color: var(--text-dim); }
        .toast-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--accent);
            cursor: pointer;
            white-space: nowrap;
        }
        .toast-btn.primary {
            background: var(--accent);
            color: var(--bg);
            border-color: var(--accent);
        }

        /* --- USER DOT --- */
        .loc-dot {
            width: 14px;
            height: 14px;
            background: #2a6bf4;
            border: 2px solid #fff;
            box-shadow: 0 0 0 6px rgba(42,107,244,0.25);
        }

        /* --- DEBUG --- */
        #debugHud {
            position: fixed;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 8px 10px;
            font: 12px/1.3 ui-monospace, monospace;
            z-index: 9999;
        }
        .dev-badge {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 9999;
            background: #8b5cf6;
            color: #fff;
            padding: 6px 10px;
            font: 700 12px/1 system-ui;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            display: none;
        }
        .dev-badge.show { display: inline-block; }

        /* --- LEAFLET OVERRIDES --- */
        .leaflet-popup-content-wrapper { border-radius: 0 !important; }
        .leaflet-popup-tip { display: none; }
        .leaflet-control-zoom a { border-radius: 0 !important; }
        .leaflet-popup-content a { text-decoration: none; pointer-events: none; color: inherit; }
        .leaflet-pane.leaflet-popup-pane { z-index: 500; }

        /* --- DESKTOP --- */
        @media (min-width: 768px) {
            .header h1 { font-size: 36px; }
            .controls, .map-wrap, .camera-section, .status-bar { max-width: 560px; margin-left: auto; margin-right: auto; }
            #map { height: calc(var(--vhpx) * 0.55); }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>SpeedWarn</h1>
        <p>Real-time speed camera alerts for San Francisco. 33 cameras. Audio warnings. 100% on your device.</p>
    </div>

    <div class="controls">
        <button id="warmup" class="btn-start" data-state="off">Enable GPS + Sound</button>
        <div class="btn-row">
            <button id="proBtn" class="btn-secondary">Go Pro</button>
            <button id="testSound" class="btn-secondary" style="display:none">Test Sound</button>
            <button id="installBtn" class="btn-secondary">Install App</button>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-inner">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">GPS inactive. Tap above to start.</span>
        </div>
    </div>

    <div class="map-wrap">
        <div id="map" tabindex="-1"></div>
    </div>

    <div class="camera-section">
        <div class="camera-header" id="cameraToggle">
            <span>Camera Locations</span>
            <span class="arrow">&#9660;</span>
        </div>
        <ul class="camera-list" id="cameraList" role="listbox" aria-label="Speed camera list"></ul>
    </div>

    <div id="speedSign" class="speed-sign" aria-live="polite" hidden>
        <div class="sign">
            <div class="label">SPEED LIMIT</div>
            <div class="value" id="speedLimitValue">--</div>
            <div class="capsule">SPEED CAMERA ZONE</div>
        </div>
    </div>

    <!-- Terms Modal -->
    <div class="modal-backdrop" id="termsModal">
        <div class="modal-box">
            <button class="modal-close" id="termsClose">&times;</button>
            <h2>Safety & Terms</h2>
            <div class="warning">Do not interact with this app while driving. Use audio alerts only.</div>
            <p>This app is informational. You must obey all posted signs and traffic laws. Alerts may be delayed, inaccurate, or unavailable.</p>
            <ul>
                <li>You are responsible for safe driving and legal compliance.</li>
                <li>Do not rely solely on the app.</li>
                <li>No guarantee of accuracy, completeness, or availability.</li>
                <li>We are not liable for tickets, fines, collisions, or other losses.</li>
            </ul>
            <label class="modal-check">
                <input type="checkbox" id="ackNotDriving">
                I will not interact with the app while the vehicle is moving.
            </label>
            <label class="modal-check">
                <input type="checkbox" id="ackAgree">
                I agree to the <a href="terms.html" target="_blank" style="color:var(--text-dim);border-bottom:1px solid var(--border)">Terms</a> and <a href="privacy.html" target="_blank" style="color:var(--text-dim);border-bottom:1px solid var(--border)">Privacy Policy</a>.
            </label>
            <button class="modal-btn" id="termsAccept" disabled>Accept & Enable</button>
            <div class="modal-version">Version <span id="termsVersionLabel"></span></div>
        </div>
    </div>

    <!-- Privacy/Onboarding Modal -->
    <div class="modal-backdrop" id="privacyModal">
        <div class="modal-box">
            <button class="modal-close" id="privacyClose">&times;</button>
            <h2>Privacy & Setup</h2>
            <p>Your location is processed entirely on your device. We do not upload or store GPS data.</p>
            <ul>
                <li>Location: used live on your phone for geofencing.</li>
                <li>Sound: alerts play locally on the device.</li>
                <li>No account required. No tracking.</li>
            </ul>
            <button class="modal-btn" id="privacyEnable">Enable GPS & Sound</button>
            <button class="modal-btn" id="privacyLater" style="background:transparent;color:var(--text-dim);border:1px solid var(--border);margin-top:8px">Not Now</button>
        </div>
    </div>

    <!-- iOS Install Modal -->
    <div class="modal-backdrop" id="iosInstall">
        <div class="modal-box">
            <button class="modal-close" id="iosClose">&times;</button>
            <h2>Install to Home Screen</h2>
            <p>For better GPS and audio on iPhone:</p>
            <ol style="padding-left:18px;font-size:13px;color:var(--text-dim);line-height:1.6">
                <li>Tap the <strong style="color:var(--text)">Share</strong> icon in Safari.</li>
                <li>Choose <strong style="color:var(--text)">Add to Home Screen</strong>.</li>
            </ol>
            <button class="modal-btn" id="iosDone">Done</button>
        </div>
    </div>

    <!-- Nag -->
    <div id="nag" class="nag-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="nag-wrap">
            <img id="nagImg" class="nag-img" src="" alt="Upgrade" decoding="async">
            <div id="nagCountdown" class="nag-count">25</div>
        </div>
    </div>

    <!-- Toasts -->
    <div class="toast-container">
        <div id="installToast" class="toast">
            <span class="toast-text">Install for faster access?</span>
            <button class="toast-btn primary" id="toastInstall">Install</button>
            <button class="toast-btn" id="toastInstallLater">Later</button>
        </div>
    </div>

    <div id="debugHud" hidden></div>
    <div id="devBadge" class="dev-badge">DEV</div>
    <div id="ariaLive" aria-live="assertive" aria-atomic="true" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">.</div>

    <footer>
        &copy; 2025-2026 SpeedWarn &middot; <a href="privacy.html">Privacy</a> &middot; <a href="contact.html">Contact</a>
    </footer>

    <script>
        function withBase(url) {
          const base = window.BASE || '';
          if (/^https?:\/\//.test(url)) return url;
          if (url.startsWith('/')) return `${base}${url}`;
          return `${base}/${url}`;
        }

        window.addEventListener('DOMContentLoaded', () => {
            const BASE = window.BASE || '';
            const DATA_BASE = `${BASE}/data`;
            const DEV = !!window.DEV;
            const ACCURACY_MAX_M = 75;

            const HAS = {
              leaflet: !!window.L,
              turf: !!window.turf,
              kdb: !!window.KDBush && !!window.geokdbush
            };

            function showFatal(msg){
              const mapBox = document.getElementById('map');
              if (mapBox) {
                const div = document.createElement('div');
                div.style.cssText = 'padding:20px;color:#d62828;font-weight:700;';
                div.textContent = msg + ' Try reloading.';
                mapBox.appendChild(div);
              }
            }

            if (!HAS.leaflet) { showFatal('Map library failed to load.'); return; }

            window.audioManifestReady = window.audioManifestReady || Promise.resolve();
            window.buildAudioUrls = window.buildAudioUrls || function(){ return []; };
            window.preloadAudioList = window.preloadAudioList || function(){};
            window.playLocationOnly = window.playLocationOnly || function(){ AudioFX.play("beep"); };
            window.applyMode = window.applyMode || function(){};
            window.stopGPS = window.stopGPS || function(){ try { window.stopCameraAlerts?.(); } catch(_){} };
            if (typeof window.nagInt === "undefined") window.nagInt = null;

            // Fix links
            document.querySelectorAll('a[href="privacy.html"]').forEach(a => a.href = `${BASE}/privacy.html`);
            document.querySelectorAll('a[href="contact.html"]').forEach(a => a.href = `${BASE}/contact.html`);
            document.querySelectorAll('a[href="terms.html"]').forEach(a => a.href = `${BASE}/terms.html`);

            // Service Worker
            const SW_VERSION = "v21";
            if ('serviceWorker' in navigator) {
              window.addEventListener('load', async () => {
                try {
                  const swUrl = `${BASE || ''}/sw.js?v=${SW_VERSION}`;
                  const reg = await navigator.serviceWorker.register(swUrl, { scope: (BASE || '/') });
                  if (reg.active) reg.update();
                  let refreshing = false;
                  navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    refreshing = true;
                    location.reload();
                  });
                } catch(e){}
              });
            }

            document.getElementById('devBadge')?.classList.toggle('show', DEV);
            try { history.scrollRestoration = 'manual'; } catch {}
            if (location.hash) { history.replaceState(null, '', location.pathname); }
            window.addEventListener('load', () => { window.scrollTo(0, 0); }, { once:true });

            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            /* -------- Camera list toggle -------- */
            const cameraToggle = document.getElementById('cameraToggle');
            const cameraListEl = document.getElementById('cameraList');
            cameraToggle?.addEventListener('click', () => {
                cameraToggle.classList.toggle('open');
                cameraListEl.classList.toggle('open');
            });

            /* -------- Stripe -------- */
            const STRIPE_URL = "https://buy.stripe.com/eVq4gA1ra1ptdAT1ZQfbq01";
            document.getElementById('proBtn')?.addEventListener('click', () => {
                window.open(STRIPE_URL, '_blank', 'noopener,noreferrer');
            });

            /* -------- Debug -------- */
            function showDebug(msg, isErr=false){
                let el = document.getElementById('debugBadge');
                if (!el){
                    el = document.createElement('div');
                    el.id = 'debugBadge';
                    el.setAttribute('role','status');
                    el.style.cssText = 'position:fixed;right:10px;bottom:10px;z-index:9999;padding:8px 10px;background:#111;color:#fff;font:600 12px system-ui;opacity:.9';
                    document.body.appendChild(el);
                }
                el.style.background = isErr ? '#8b0000' : '#111';
                el.textContent = msg;
            }
            window.addEventListener('error', e => showDebug(e.message, true));
            window.addEventListener('unhandledrejection', e => showDebug(String(e.reason), true));

            async function fetchJSON(url){
                try{
                    const isDev = !!window.DEV;
                    const finalUrl = isDev ? `${url}${url.includes('?') ? '&' : '?'}v=${Date.now()}` : url;
                    const r = await fetch(finalUrl, { cache: isDev ? 'no-store' : 'default' });
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return await r.json();
                }catch(e){
                    console.warn('Fetch failed', url, e);
                    showDebug(`Failed: ${url.split('/').pop()}`, true);
                    throw e;
                }
            }

            /* -------- Map -------- */
            let map, userMarker;
            const poleLayer = L.layerGroup();
            const areaLayer = L.layerGroup();
            const corridorPolys = [];

            function initMap(){
                map = L.map('map',{ zoomControl:true }).setView([37.7749,-122.4194],12);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OSM' }).addTo(map);
                poleLayer.addTo(map);
                areaLayer.addTo(map);
                const dot = L.divIcon({ className:'loc-dot' });
                userMarker = L.marker([37.7749,-122.4194],{icon:dot});
                window.map = map;
            }

            /* -------- Audio -------- */
            (() => {
              const SFX = {
                manifest: { beep: "images/audio/beep.mp3", nag: "images/audio/Ad1.mp3" },
                ctx: null, buffers: new Map(), unlocked: false, loading: null,
              };
              function ensureCtx() {
                const injected = (window.AudioUnlock && window.AudioUnlock !== window.AudioFX && window.AudioUnlock.ctx) || null;
                if (injected) { SFX.ctx = injected; return injected; }
                if (!SFX.ctx) SFX.ctx = new (window.AudioContext || window.webkitAudioContext)();
                return SFX.ctx;
              }
              async function loadAll() {
                if (SFX.loading) return SFX.loading;
                const ctx = ensureCtx();
                SFX.loading = Promise.all(Object.entries(SFX.manifest).map(async ([id, url]) => {
                  const res = await fetch(withBase(url), { cache: "reload" }).catch(()=>null);
                  if (!res || !res.ok) return;
                  const arr = await res.arrayBuffer();
                  const buf = await ctx.decodeAudioData(arr).catch(()=>null);
                  if (buf) SFX.buffers.set(id, buf);
                }));
                return SFX.loading;
              }
              async function unlock() {
                if (SFX.unlocked) return;
                const ctx = ensureCtx();
                if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
                const node = ctx.createBufferSource();
                node.buffer = ctx.createBuffer(1, 1, 22050);
                node.connect(ctx.destination);
                node.start(0);
                SFX.unlocked = true;
                await loadAll();
              }
              async function play(id, {gain=1.0, rate=1.0} = {}) {
                try {
                  if (window.mode !== 'on') return;
                  const standalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator && navigator.standalone === true);
                  if (document.visibilityState !== 'visible' && !standalone) return;
                  const ctx = ensureCtx();
                  if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
                  if (!SFX.buffers.size) await loadAll();
                  const buf = SFX.buffers.get(id);
                  if (!buf) return;
                  const src = ctx.createBufferSource();
                  const g = ctx.createGain();
                  src.buffer = buf; src.playbackRate.value = rate;
                  src.connect(g); g.gain.value = gain; g.connect(ctx.destination);
                  src.start(0);
                } catch(e){}
              }
              window.AudioFX = { unlock, play, loadAll, get ctx(){ return ensureCtx(); } };
              window.AudioUnlock = window.AudioUnlock || window.AudioFX;
              ["pointerdown","touchstart","click"].forEach(evt=>{
                window.addEventListener(evt, unlock, { once: true, passive: true });
              });
            })();
            window.addEventListener("load", () => { setTimeout(()=>AudioFX.loadAll(), 1000); });

            /* -------- Poles & Corridors (same logic as before) -------- */
            const CORRIDORS_URL = `${DATA_BASE}/corridors.json`;
            const POLES_URL = `${DATA_BASE}/poles.json`;
            const POLY_STYLE = { stroke:false, weight:0, color:'#1e88e5', opacity:0, fillColor:'#1e88e5', fillOpacity:0.18 };

            function toRad(d){return d*Math.PI/180}
            function distKm(aLat,aLon,bLat,bLon){
                const R=6371,dLat=toRad(bLat-aLat),dLon=toRad(bLon-aLon);
                const s=Math.sin(dLat/2)**2+Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*Math.sin(dLon/2)**2;
                return R*2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s));
            }
            function nearestCameraName(lat, lon){
                let best=null, bestD=Infinity;
                for (const c of cameras){
                    const d = distKm(lat, lon, c.lat, c.lon);
                    if (d < bestD){ bestD = d; best = c.name; }
                }
                return best;
            }
            function pushCorridorPolys(geo){
                if (!geo) return;
                const pushOne = (feat) => {
                    const t = feat?.geometry?.type;
                    if (t === 'Polygon' || t === 'MultiPolygon') corridorPolys.push(feat);
                };
                if (geo.type === 'Feature') pushOne(geo);
                else if (geo.type === 'FeatureCollection') (geo.features || []).forEach(pushOne);
            }
            function normalizeToPolygons(fc) {
              if (!window.turf) return (fc && fc.type === 'FeatureCollection') ? fc : { type:'FeatureCollection', features: [] };
              const out = [];
              for (const f of (fc?.features||[])) {
                const t = f?.geometry?.type || '';
                if (t.includes('Line')) {
                  try {
                    const buf = turf.buffer(f, 0.02, { units: 'kilometers' });
                    if (buf?.type === 'FeatureCollection') (buf.features||[]).forEach(bf => out.push(bf));
                    else if (buf) out.push(buf);
                  } catch {}
                } else if (t === 'Polygon' || t === 'MultiPolygon') {
                  out.push(f);
                }
              }
              return { type:'FeatureCollection', features: out };
            }
            function addCorridors(fc){
                const layer = L.geoJSON(fc, {
                    style: POLY_STYLE,
                    onEachFeature: (feat, l) => {
                        const nm = feat.properties?.CORRIDOR || feat.properties?.Name || feat.properties?.Segment || feat.properties?.name || 'Approach Area';
                        l.bindPopup(nm);
                    }
                }).addTo(areaLayer);
                pushCorridorPolys(fc);
                return layer;
            }
            function polyToMultiLine(feature){
                try {
                    const out = turf.polygonToLine(feature);
                    if (!out) return null;
                    if (out.type === 'Feature' && /LineString/i.test(out.geometry?.type)) return out;
                    if (out.type === 'Feature' && out.geometry?.type === 'MultiLineString') return out;
                    if (out.type === 'FeatureCollection') {
                        const lines = out.features.map(f => f.geometry).filter(g => g && /LineString/i.test(g.type)).map(g => g.coordinates);
                        if (lines.length) return turf.multiLineString(lines);
                    }
                } catch {}
                return null;
            }
            function snapToPolygonEdge(lng, lat, polyFeature){
                try{
                    const pt = turf.point([lng, lat]);
                    const line = polyToMultiLine(polyFeature) || (polyFeature?.geometry?.coordinates?.[0] ? turf.lineString(polyFeature.geometry.coordinates[0]) : null);
                    if (!line) return [lat, lng];
                    const snapped = turf.nearestPointOnLine(line, pt, { units: 'kilometers' });
                    const [slng, slat] = snapped.geometry.coordinates;
                    return [slat, slng];
                }catch{ return [lat, lng]; }
            }
            function filterCorridorsToPoles(corridorsFC, polesFC){
              if (!window.turf) {
                return {
                  fc: { type:'FeatureCollection', features: (corridorsFC.features || []).filter(f => { const t = f.geometry?.type; return t === 'Polygon' || t === 'MultiPolygon'; }) },
                  corridorForPole: new Map()
                };
              }
              const polys = (corridorsFC.features || []).filter(f => { const t = f.geometry?.type; return t === 'Polygon' || t === 'MultiPolygon'; });
              const centers = polys.map((f, i) => ({ i, c: turf.centerOfMass(f) }));
              const poles = (polesFC.features || []).filter(f => f.geometry?.type === 'Point');
              const picked = new Set();
              const selected = [];
              const corridorForPole = new Map();
              for (const pole of poles){
                  const name = pole.properties?.name || `pole_${selected.length+1}`;
                  const pt = turf.point(pole.geometry.coordinates);
                  const ranked = centers.map(({i, c}) => ({ i, d: turf.distance(pt, c, { units: 'kilometers' }) })).sort((a,b)=>a.d-b.d);
                  const choice = ranked.find(r => !picked.has(r.i))?.i ?? ranked[0]?.i;
                  if (choice != null){
                      picked.add(choice);
                      selected.push(polys[choice]);
                      corridorForPole.set(name, polys[choice]);
                  }
              }
              return { fc: { type:'FeatureCollection', features: selected }, corridorForPole };
            }
            function addPoleMarkers(fc, corridorForPole){
                const camIcon = L.icon({
                    iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><rect x="4" y="4" width="20" height="20" fill="#d62828" stroke="white" stroke-width="3"/></svg>'),
                    iconSize:[28,28],
                    iconAnchor:[14,14]
                });
                const feats = (fc.features||[]).filter(f=>{
                    const g = f.geometry || {};
                    if (g.type !== 'Point' || !Array.isArray(g.coordinates)) return false;
                    const [x,y]=g.coordinates;
                    return x>-124&&x<-121&&y>37&&y<38;
                });
                const ul = document.getElementById('cameraList');
                if (ul) ul.innerHTML = '';
                const latlngs=[];
                for (const f of feats){
                    const [lng,lat]=f.geometry.coordinates;
                    const name = f.properties?.name || 'Speed Camera';
                    const poly = corridorForPole?.get(name);
                    const [snapLat, snapLng] = poly ? snapToPolygonEdge(lng, lat, poly) : [lat, lng];
                    const m = L.marker([snapLat, snapLng],{icon:camIcon}).addTo(poleLayer);
                    const div = document.createElement('div');
                    div.textContent = name;
                    m.bindPopup(div);
                    m.on('click', ()=>{ if (LOC[name]) playLocationOnly(name); });
                    latlngs.push([snapLat, snapLng]);
                    if (ul){
                        const li=document.createElement('li');
                        li.textContent=name;
                        li.setAttribute('role','option');
                        li.setAttribute('tabindex','0');
                        li.addEventListener('click',()=>{
                            map.setView([snapLat,snapLng],15);
                            if(LOC[name]) playLocationOnly(name);
                        });
                        li.addEventListener('keydown', (e)=>{
                            if(e.key==='Enter'||e.key===' '){ e.preventDefault(); li.click(); }
                        });
                        ul.appendChild(li);
                    }
                }
                if(latlngs.length) map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
            }

            /* -------- Speed sign -------- */
            let speedSignTO=null;
            const DEFAULT_LIMIT = 30;
            const SPEED_SIGN_MS = DEV ? 2000 : 5000;
            function showSpeedSign(limit){
                const box = document.getElementById('speedSign');
                const val = document.getElementById('speedLimitValue');
                if (!box || !val) return;
                const usingFallback = !Number.isFinite(limit);
                const toShow = usingFallback ? DEFAULT_LIMIT : limit;
                box.classList.remove('fallback','unknown');
                box.classList.toggle('fallback', usingFallback);
                box.classList.toggle('unknown', usingFallback);
                val.textContent = String(toShow);
                box.hidden = false;
                box.classList.add('show');
                if (window.mode === 'on') AudioFX.play("beep");
                clearTimeout(speedSignTO);
                speedSignTO = setTimeout(hideSpeedSign, SPEED_SIGN_MS);
            }
            function hideSpeedSign(){
                const box=document.getElementById('speedSign');
                if(!box) return;
                box.classList.remove('show');
                clearTimeout(speedSignTO);
                speedSignTO=null;
                setTimeout(()=>{box.hidden=true;},200);
            }

            /* -------- Gates / timing -------- */
            (function(){
              const hasTurf = !!window.turf;
              const CFG = {
                baseEnterM: 180, baseExitM: 240, fovDeg: 60,
                cooldownMs: 2*60*1000, globalCooldownMs: 3000, accuracyMaxM: ACCURACY_MAX_M
              };
              let lastGlobalAlert = 0;
              const state = new Map();
              const meters = hasTurf
                ? (a,b)=>turf.distance(a,b,{units:"kilometers"})*1000
                : (a,b)=>{
                    const [lngA, latA] = a.geometry.coordinates;
                    const [lngB, latB] = b.geometry.coordinates;
                    const R=6371, dLat=(latB-latA)*Math.PI/180, dLon=(lngB-lngA)*Math.PI/180;
                    const s=Math.sin(dLat/2)**2+Math.cos(latA*Math.PI/180)*Math.cos(latB*Math.PI/180)*Math.sin(dLon/2)**2;
                    return R*2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s))*1000;
                  };
              const bearing = hasTurf
                ? (a,b)=>turf.bearing(a,b)
                : (a,b)=>{
                    const [lngA, latA] = a.geometry.coordinates.map(v=>v*Math.PI/180);
                    const [lngB, latB] = b.geometry.coordinates.map(v=>v*Math.PI/180);
                    const y = Math.sin(lngB-lngA)*Math.cos(latB);
                    const x = Math.cos(latA)*Math.sin(latB)-Math.sin(latA)*Math.cos(latB)*Math.cos(lngB-lngA);
                    return (Math.atan2(y,x)*180/Math.PI + 360) % 360;
                  };
              const diff = (a,b)=>Math.min((360+((a-b)%360))%360,(360+((b-a)%360))%360);
              function dynamicRadii(speedMps){
                const enter = Math.max(CFG.baseEnterM, (speedMps||0)*10);
                const exit = Math.max(CFG.baseExitM, enter + 60);
                return { ENTER_M: enter, EXIT_M: exit };
              }
              function facingOK(cam, lastPos, pos){
                const dir = String(cam.facing || cam.properties?.facing || "BOTH").toUpperCase();
                if (dir === "BOTH") return true;
                if (!pos) return true;
                const here = { type:"Feature", geometry:{ type:"Point", coordinates:[pos.coords.longitude, pos.coords.latitude] } };
                const prev = lastPos
                  ? { type:"Feature", geometry:{ type:"Point", coordinates:[lastPos.coords.longitude, lastPos.coords.latitude] } }
                  : here;
                const drive = bearing(prev, here);
                const nominal = ({N:0,NB:0,NE:45,E:90,EB:90,SE:135,S:180,SB:180,SW:225,W:270,WB:270,NW:315})[dir];
                if (nominal == null) return true;
                return diff(drive, nominal) <= (CFG.fovDeg/2);
              }
              window.shouldAlertCameraPro = function(cam, lastPos, pos, speedMps){
                if (pos?.coords?.accuracy && pos.coords.accuracy > CFG.accuracyMaxM) return false;
                const id = cam.id ?? cam.pole_id ?? cam.name ?? JSON.stringify(cam.geometry?.coordinates);
                if (!id) return false;
                const here = { type:"Feature", geometry:{ type:"Point", coordinates:[pos.coords.longitude, pos.coords.latitude] } };
                const there = { type:"Feature", geometry:{ type:"Point", coordinates: cam.geometry?.coordinates ?? cam.coords } };
                const d = meters(here, there);
                const { ENTER_M, EXIT_M } = dynamicRadii(speedMps);
                let s = state.get(id) || { inZone:false, lastFired:0 };
                if (!s.inZone && d <= ENTER_M) s.inZone = true;
                if (s.inZone && d >= EXIT_M) s.inZone = false;
                const now = Date.now();
                const cooled = (now - s.lastFired) > CFG.cooldownMs;
                const globalCooled = (now - lastGlobalAlert) > CFG.globalCooldownMs;
                const okFacing = facingOK(cam, lastPos, pos);
                const fire = s.inZone && cooled && globalCooled && okFacing;
                if (fire) { s.lastFired = now; lastGlobalAlert = now; }
                state.set(id, s);
                return fire;
              };
              window.__alertState = ()=>({ size: state.size });
              if (DEV) window.__alertCFG = CFG;
            })();

            /* -------- Geolocation watch loop -------- */
            (function(){
              const OPTS = { throttleMs: 800, highAcc: true, maxAgeMs: 4000, timeoutMs: 10000, userMarker: { radius: 6 }, nearestSearchLimit: 1500, drawUserTrail: false };
              let watchId = null, lastPos = null, lastTick = 0, userDot = null, userTrail = null, camLayer = null, currentNearestId = null;

              function normalizeCamera(feature){
                if (!feature) return null;
                const p = feature.properties || {};
                const id = p.id ?? p.pole_id ?? p.name ?? feature.id ?? JSON.stringify(feature.geometry?.coordinates);
                const facing = (p.direction ?? p.facing ?? "BOTH");
                const speedLimit = getCameraSpeedLimit(feature);
                return { id, facing, speedLimit, properties: p, geometry: feature.geometry };
              }
              function findNearestCamera(pos, features){
                if (!features || !features.length) return { feature:null, distM: Infinity, idx:-1 };
                const hereLat = pos.coords.latitude, hereLng = pos.coords.longitude;
                let best = { feature:null, distM: Infinity, idx:-1 };
                for (let i=0; i<features.length; i++){
                  const f = features[i];
                  const [lng, lat] = (f.geometry && f.geometry.coordinates) || [];
                  if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
                  const d = distKm(hereLat, hereLng, lat, lng) * 1000;
                  if (d < best.distM) best = { feature:f, distM:d, idx:i };
                }
                return best;
              }
              function renderUser(pos){
                const lat = pos.coords.latitude, lng = pos.coords.longitude;
                if (!userDot){
                  userDot = L.circleMarker([lat, lng], { radius: OPTS.userMarker.radius, weight:2, color:'#0af', fillColor:'#0af', fillOpacity:0.7 });
                  userDot.addTo(map);
                } else userDot.setLatLng([lat, lng]);
              }
              function renderNearestHighlight(feature){
                if (!feature) { if (camLayer) { map.removeLayer(camLayer); camLayer = null; } return; }
                const [lng, lat] = feature.geometry.coordinates;
                if (!camLayer){
                  camLayer = L.circleMarker([lat, lng], { radius:5, color:'#ff0', weight:2, fillOpacity:0.2 });
                  camLayer.addTo(map);
                } else camLayer.setLatLng([lat, lng]);
              }
              function onPosition(pos, camerasFC){
                if (!DEV && pos?.coords?.accuracy && pos.coords.accuracy > ACCURACY_MAX_M) { lastPos = pos; return; }
                const now = Date.now();
                if (now - lastTick < OPTS.throttleMs) return;
                lastTick = now;
                renderUser(pos);
                const NEAR = (window.findNearestCameraFast || findNearestCamera);
                const { feature, distM } = NEAR(pos, camerasFC.features || []);
                const camObj = normalizeCamera(feature);
                const HUD = document.getElementById('debugHud');
                window.updateDebug = (o={})=>{ HUD.hidden = false; HUD.textContent = JSON.stringify(o, null, 0); };
                if (window.updateDebug) {
                  const mph = (pos.coords.speed != null && isFinite(pos.coords.speed)) ? Math.round(pos.coords.speed * 2.23694) : null;
                  window.updateDebug({ distM: feature ? Math.round(distM) : null, nearestId: camObj?.id ?? null, speedMph: mph });
                }
                // Update status bar
                const statusText = document.getElementById('statusText');
                if (statusText && feature) {
                    const d = Math.round(distM);
                    statusText.textContent = d < 1000 ? `Nearest camera: ${d}m` : `Nearest camera: ${(distM/1000).toFixed(1)}km`;
                }
                if (!feature || distM > OPTS.nearestSearchLimit) { renderNearestHighlight(null); lastPos = pos; return; }
                renderNearestHighlight(feature);
                const fired = (window.shouldAlertCameraPro || window.shouldAlertCamera)(camObj, lastPos, pos, pos.coords.speed);
                if (fired) showSpeedLimitPopup(camObj);
                currentNearestId = camObj?.id ?? null;
                lastPos = pos;
              }
              function onError(err){ console.warn("Geolocation error:", err?.code, err?.message); }
              function startCameraAlerts(camerasGeoJSON = window.CAMERAS_GEOJSON){
                if (!('geolocation' in navigator)) return { stop(){} };
                if (!camerasGeoJSON || !camerasGeoJSON.features) return { stop(){} };
                if (window.AudioFX?.loadAll) AudioFX.loadAll();
                const opts = { enableHighAccuracy: OPTS.highAcc, maximumAge: OPTS.maxAgeMs, timeout: OPTS.timeoutMs };
                if (watchId !== null) navigator.geolocation.clearWatch(watchId);
                watchId = navigator.geolocation.watchPosition((pos)=>onPosition(pos, camerasGeoJSON), onError, opts);
                return { stop: stopCameraAlerts };
              }
              function stopCameraAlerts(){
                if (watchId !== null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
                if (camLayer) { map.removeLayer(camLayer); camLayer = null; }
              }
              window.startCameraAlerts = startCameraAlerts;
              window.stopCameraAlerts = stopCameraAlerts;
            })();

            /* -------- Load cameras -------- */
            (function(){
              async function loadCamerasAndStart({ url = 'data/poles.json', drawPoles = true, autoStart = true } = {}){
                try {
                  const res = await fetch(withBase(url), { cache: 'reload' });
                  if (!res.ok) throw new Error(`HTTP ${res.status}`);
                  const raw = await res.json();
                  const fc = (raw && raw.type === 'FeatureCollection') ? raw : { type: 'FeatureCollection', features: Array.isArray(raw) ? raw : [] };
                  const features = (fc.features || []).map((f, i) => {
                    const g = f?.geometry || {};
                    let coords = g.coordinates;
                    if (!coords || coords.length !== 2) return null;
                    const [a,b] = coords;
                    const looksLatLng = Math.abs(a) <= 90 && Math.abs(b) <= 180;
                    const looksLngLat = Math.abs(a) <= 180 && Math.abs(b) <= 90;
                    if (looksLatLng && !looksLngLat) coords = [b, a];
                    const p = f.properties || {};
                    const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                    const facing = String(p.direction ?? p.facing ?? 'BOTH').toUpperCase();
                    const speedLimit = getCameraSpeedLimit(f);
                    return { type: 'Feature', id, properties: { ...p, id, facing, speedLimit }, geometry: { type: 'Point', coordinates: coords } };
                  }).filter(Boolean);
                  window.CAMERAS_GEOJSON = { type: 'FeatureCollection', features };
                  if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(features);
                  if (drawPoles && typeof window.addPolesAndApproaches === 'function') window.addPolesAndApproaches(window.CAMERAS_GEOJSON, { offsetMeters: 5 });
                  if (autoStart && typeof window.startCameraAlerts === 'function') window.startCameraAlerts(window.CAMERAS_GEOJSON);
                } catch (err) {
                  try {
                    if ('caches' in window) {
                      const match = await caches.match(withBase(url));
                      if (match) {
                        const raw = await match.json();
                        const fc = (raw && raw.type === 'FeatureCollection') ? raw : { type: 'FeatureCollection', features: Array.isArray(raw) ? raw : [] };
                        const features = (fc.features || []).map((f, i) => {
                          const g = f?.geometry || {};
                          let coords = g.coordinates;
                          if (!coords || coords.length !== 2) return null;
                          const [a,b] = coords;
                          if (Math.abs(a) <= 90 && !(Math.abs(a) <= 180 && Math.abs(b) <= 90)) coords = [b, a];
                          const p = f.properties || {};
                          const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                          return { type: 'Feature', id, properties: { ...p, id, facing: String(p.direction ?? p.facing ?? 'BOTH').toUpperCase(), speedLimit: getCameraSpeedLimit(f) }, geometry: { type: 'Point', coordinates: coords } };
                        }).filter(Boolean);
                        window.CAMERAS_GEOJSON = { type: 'FeatureCollection', features };
                        if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(features);
                        if (autoStart !== false && window.startCameraAlerts) window.startCameraAlerts(window.CAMERAS_GEOJSON);
                      }
                    }
                  } catch(_) {}
                }
              }
              window.loadCamerasAndStart = loadCamerasAndStart;
            })();

            /* -------- KDBush spatial index -------- */
            (function(){
              let __idx = null, __pts = null;
              window.buildCameraIndex = function(features){
                if (!HAS.kdb) return null;
                __pts = (features||[]).map((f,i)=>{ const [lng,lat] = f.geometry.coordinates; return { i, lng, lat }; });
                __idx = new KDBush(__pts, p=>p.lng, p=>p.lat, 64, Float64Array);
                return __idx;
              };
              window.findNearestCameraFast = function(pos, features){
                if (!HAS.kdb || !__idx || !__pts) return { feature:null, distM: Infinity, idx:-1 };
                const lng = pos.coords.longitude, lat = pos.coords.latitude;
                const nearest = geokdbush.around(__idx, lng, lat, 1)[0];
                if (!nearest) return { feature:null, distM: Infinity, idx:-1 };
                const f = features[nearest.i];
                const distM = turf
                  ? turf.distance(turf.point([lng,lat]), turf.point(f.geometry.coordinates), {units:"kilometers"})*1000
                  : distKm(lat,lng,f.geometry.coordinates[1],f.geometry.coordinates[0])*1000;
                return { feature:f, distM, idx:nearest.i };
              };
            })();

            /* -------- Approach visualization -------- */
            function addPolesAndApproaches(geojson, {offsetMeters=5}={}){
              if (!window.turf) return null;
              const approachPoleLayer = L.layerGroup().addTo(map);
              const approachLayer = L.layerGroup().addTo(map);
              geojson.features.forEach(f=>{
                const coords = f.geometry.coordinates;
                const pt = turf.point(coords);
                const dir = (f.properties?.facing || "BOTH").toUpperCase();
                const bearingMap = {N:0,NB:0,NE:45,E:90,EB:90,SE:135,S:180,SB:180,SW:225,W:270,WB:270,NW:315};
                const bearingDeg = bearingMap[dir] ?? 90;
                const rightDeg = (bearingDeg + 90) % 360;
                const offsetPt = turf.destination(pt, offsetMeters/1000, rightDeg, {units:"kilometers"});
                const [lng, lat] = offsetPt.geometry.coordinates;
                L.circleMarker([lat,lng], {radius:4, weight:1, opacity:0.9, fillOpacity:0.9}).addTo(approachPoleLayer);
                if (dir !== "BOTH") {
                  const back = turf.destination(pt, 0.12, (bearingDeg+180)%360, {units:"kilometers"});
                  L.polyline([[back.geometry.coordinates[1], back.geometry.coordinates[0]],[lat, lng]], {dashArray:"4,4", opacity:0.7}).addTo(approachLayer);
                }
              });
              return { approachPoleLayer, approachLayer };
            }
            window.addPolesAndApproaches = addPolesAndApproaches;

            /* -------- Speed limit popup -------- */
            function showSpeedLimitPopup(cam){
              const limit = getCameraSpeedLimit(cam);
              const html = limit ? `<b>Speed limit: ${limit} mph</b>` : `<b>Speed camera</b>`;
              try {
                const coords = cam?.geometry?.coordinates;
                if (Array.isArray(coords) && coords.length === 2 && isFinite(coords[0]) && isFinite(coords[1])) {
                  L.popup({autoClose:true, closeOnClick:true}).setLatLng([coords[1], coords[0]]).setContent(html).openOn(map);
                }
              } catch {}
              if (window.mode === 'on') AudioFX.play("beep");
              const txt = limit ? `Speed limit ${limit} miles per hour` : `Speed camera ahead`;
              try{ window.announce?.(txt); }catch(e){}
            }
            (function(){
              const MIN_INTERVAL_MS = 3000; let last = 0;
              const _show = showSpeedLimitPopup;
              window.showSpeedLimitPopup = function(cam){ const now = Date.now(); if (now - last < MIN_INTERVAL_MS) return; last = now; _show?.(cam); };
            })();
            (function(){
              const MIN_MS = 3000; let last = 0;
              const _show = showSpeedSign;
              window.showSpeedSign = function(limit){ const now = Date.now(); if (now - last < MIN_MS) return; last = now; _show?.(limit); };
            })();

            function getCameraSpeedLimit(cam){
              const v = cam?.speedLimit ?? cam?.properties?.speedLimit;
              const n = (typeof v === "string") ? parseFloat(v) : v;
              return (Number.isFinite(n)) ? Math.round(n) : null;
            }

            /* -------- Map resize -------- */
            (function(){
              let _timer = null;
              const kick = ()=>{ clearTimeout(_timer); _timer = setTimeout(()=> map?.invalidateSize?.(), 150); };
              window.addEventListener('resize', kick);
              window.addEventListener('orientationchange', kick);
              window.mapKickResize = kick;
            })();

            window.announce = (msg)=>{ const n=document.getElementById('ariaLive'); if(n) n.textContent=String(msg||''); };

            /* -------- Init -------- */
            initMap();
            loadCamerasAndStart({ autoStart: false, drawPoles: false });

            let cameras = [];
            let dataReadyResolve;
            const dataReady = new Promise(res => (dataReadyResolve = res));

            function normalizePolesFC(polesFC){
              const raw = (polesFC && polesFC.type === 'FeatureCollection') ? polesFC : { type: 'FeatureCollection', features: Array.isArray(polesFC) ? polesFC : [] };
              const features = (raw.features || []).map((f, i) => {
                const g = f?.geometry || {};
                let coords = g.coordinates;
                if (!coords || coords.length !== 2) return null;
                const [a,b] = coords;
                if (Math.abs(a) <= 90 && !(Math.abs(a) <= 180 && Math.abs(b) <= 90)) coords = [b, a];
                const p = f.properties || {};
                const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                const facing = String(p.direction ?? p.facing ?? 'BOTH').toUpperCase();
                const speedLimit = getCameraSpeedLimit({ properties: p });
                return { type: 'Feature', id, properties: { ...p, id, facing, speedLimit }, geometry: { type: 'Point', coordinates: coords } };
              }).filter(Boolean);
              return { type: 'FeatureCollection', features };
            }

            (async () => {
                try {
                    const [corrRaw, polesRaw] = await Promise.all([fetchJSON(CORRIDORS_URL), fetchJSON(POLES_URL)]);
                    const corrPolysFC = normalizeToPolygons(corrRaw || { type:'FeatureCollection', features: [] });
                    const polesFC = normalizePolesFC(polesRaw);
                    cameras = (polesFC.features || []).map(f => {
                      const [lng, lat] = f.geometry.coordinates;
                      return { name: f.properties?.name || 'Speed Camera', lat, lon: lng, direction: (f.properties?.facing || 'BOTH').toUpperCase(), pole_id: f.properties?.pole_id };
                    });
                    const { fc: corr33, corridorForPole } = filterCorridorsToPoles(corrPolysFC, polesFC);
                    addCorridors(corr33);
                    addPoleMarkers(polesFC, corridorForPole);
                    showDebug(`${(polesFC.features||[]).length} cameras loaded`);
                    window.CAMERAS_GEOJSON = polesFC;
                    if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(polesFC.features);
                    await loadSpeedLimits();
                    dataReadyResolve();
                } catch (e) { dataReadyResolve(); }
                await window.audioManifestReady;
                setTimeout(() => { preloadAudioList(buildAudioUrls(), isMobile ? 2 : 3); }, 300);
            })();

            addEventListener('pagehide', () => {
              try { window.stopGPS?.(); } catch(_) {}
              try { clearInterval(window.nagInt || 0); } catch(_) {}
            }, { once: true });

            // --- Mode management ---
            window.mode = window.mode || 'off';
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            window.applyMode = function(){
              const btn = document.getElementById('warmup');
              if (!btn) return;
              if (window.mode === 'off') {
                btn.dataset.state = 'off';
                btn.textContent = 'Enable GPS + Sound';
                statusDot.classList.remove('active');
                statusText.textContent = 'GPS inactive. Tap above to start.';
                window.stopGPS?.();
              } else if (window.mode === 'on') {
                btn.dataset.state = 'on';
                btn.textContent = 'GPS + Sound: Active';
                statusDot.classList.add('active');
                statusText.textContent = 'Listening for cameras...';
                window.startGPS?.();
              } else {
                btn.dataset.state = 'mute';
                btn.textContent = 'GPS Only (Muted)';
                statusDot.classList.add('active');
                statusText.textContent = 'GPS active, sound muted.';
                window.startGPS?.();
              }
            };
            window.applyMode();

            /* -------- Warmup button -------- */
            const warmBtn = document.getElementById('warmup');
            const testBtn = document.getElementById('testSound');
            let preloaded = false;

            warmBtn.addEventListener('click', async () => {
              const next = (window.mode==='off') ? 'on' : (window.mode==='on' ? 'mute' : 'off');
              const proceed = () => {
                window.mode = next;
                window.applyMode();
                (async () => {
                  try {
                    await AudioUnlock.unlock();
                    if (!preloaded){ preloaded=true; setTimeout(()=>preloadAudioList(buildAudioUrls(), isMobile?2:3), 150); }
                  } catch (e) {}
                })();
              };
              if (window.mode === 'off' && (next === 'on' || next === 'mute') && !termsAccepted()) {
                showTermsModal(proceed);
                return;
              }
              proceed();
            });

            if (DEV && testBtn) testBtn.style.display = '';
            testBtn?.addEventListener('click', async ()=>{
                if (!window.AUDIO_BASE) return;
                await audioManifestReady;
                await ensureAudioReady();
                await playNow(`${AUDIO_BASE}speed_camera_ahead_1.mp3`);
                await playNow(`${AUDIO_BASE}${pick(TAGS)}`);
            });

            /* -------- Simple modal helpers -------- */
            function openModal(id) { document.getElementById(id)?.classList.add('show'); }
            function closeModal(id) { document.getElementById(id)?.classList.remove('show'); }

            /* -------- Terms -------- */
            const TERMS_VER = "2025-01-18";
            const TERMS_KEY = "terms_accept_v1";

            function lsSet(k, v) { try { localStorage.setItem(k, v); return true; } catch { try { document.cookie = `${encodeURIComponent(k)}=${encodeURIComponent(v)}; path=/; expires=${new Date(Date.now()+7*864e5).toUTCString()}`; } catch {} return false; } }
            function lsGet(k) { try { const v = localStorage.getItem(k); if (v != null) return v; } catch {} try { return document.cookie.split('; ').map(s=>s.split('=')).reduce((a,[kk,v])=>(a[decodeURIComponent(kk)]=decodeURIComponent(v||''),a),{})[k]||null; } catch { return null; } }

            function termsAccepted() {
              const raw = lsGet(TERMS_KEY);
              if (!raw) return false;
              try { return JSON.parse(raw).ver === TERMS_VER; } catch { return false; }
            }

            function showTermsModal(onAccept) {
              document.getElementById('termsVersionLabel').textContent = TERMS_VER;
              openModal('termsModal');
              const ack1 = document.getElementById('ackNotDriving');
              const ack2 = document.getElementById('ackAgree');
              const btn = document.getElementById('termsAccept');
              const enable = () => { btn.disabled = !(ack1?.checked && ack2?.checked); };
              ack1.onchange = enable;
              ack2.onchange = enable;
              enable();
              btn.onclick = () => {
                lsSet(TERMS_KEY, JSON.stringify({ ver: TERMS_VER, ts: Date.now() }));
                closeModal('termsModal');
                onAccept?.();
              };
            }

            document.getElementById('termsClose')?.addEventListener('click', () => closeModal('termsModal'));

            /* -------- Onboarding -------- */
            const ONBOARD_KEY = 'onboard_privacy_v1';
            const PWA_DONE_KEY = 'pwa_installed_v1';
            const PWA_LATER_KEY = 'pwa_install_later_ts';
            const THREE_DAYS = 3 * 24 * 60 * 60 * 1000;

            function showPrivacyModalIfNeeded() {
              if (lsGet(ONBOARD_KEY)) return;
              openModal('privacyModal');
            }

            document.getElementById('privacyEnable')?.addEventListener('click', async () => {
              try { await AudioUnlock.unlock(); } catch {}
              lsSet(ONBOARD_KEY, '1');
              closeModal('privacyModal');
              const go = () => document.getElementById('warmup')?.click();
              if (termsAccepted()) go(); else showTermsModal(go);
            });

            document.getElementById('privacyLater')?.addEventListener('click', () => closeModal('privacyModal'));
            document.getElementById('privacyClose')?.addEventListener('click', () => closeModal('privacyModal'));

            /* -------- PWA Install -------- */
            let deferredPrompt = null;
            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; });

            document.getElementById('installBtn')?.addEventListener('click', () => promptPWAInstall());

            async function promptPWAInstall() {
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const choice = await deferredPrompt.userChoice.catch(() => ({ outcome: 'dismissed' }));
                    if (choice?.outcome === 'accepted') lsSet(PWA_DONE_KEY, '1');
                    deferredPrompt = null;
                    return;
                }
                if (isIOS) {
                    openModal('iosInstall');
                    return;
                }
                // Show install toast for other browsers
                document.getElementById('installToast')?.classList.add('show');
            }

            document.getElementById('iosDone')?.addEventListener('click', () => { lsSet(PWA_DONE_KEY, '1'); closeModal('iosInstall'); });
            document.getElementById('iosClose')?.addEventListener('click', () => { lsSet(PWA_LATER_KEY, String(Date.now())); closeModal('iosInstall'); });
            document.getElementById('toastInstall')?.addEventListener('click', async () => { document.getElementById('installToast')?.classList.remove('show'); await promptPWAInstall(); });
            document.getElementById('toastInstallLater')?.addEventListener('click', () => { document.getElementById('installToast')?.classList.remove('show'); lsSet(PWA_LATER_KEY, String(Date.now())); });

            function shouldRemindInstall() {
                if (lsGet(PWA_DONE_KEY)) return false;
                const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator && navigator.standalone === true);
                if (isStandalone) return false;
                const later = parseInt(lsGet(PWA_LATER_KEY) || '0', 10);
                return !later || (Date.now() - later) > THREE_DAYS;
            }

            if (lsGet(ONBOARD_KEY)) {
                if (shouldRemindInstall()) setTimeout(() => document.getElementById('installToast')?.classList.add('show'), 10000);
            } else {
                showPrivacyModalIfNeeded();
            }

            /* -------- Audio -------- */
            const AUDIO_BASE = `${BASE}/images/audio/`;
            async function ensureAudioReady(){
                try{ await AudioUnlock.unlock(); const ctx = AudioUnlock.ctx; if (ctx && ctx.state === 'suspended') await ctx.resume(); }catch{}
            }
            window.addEventListener('touchend', () => AudioUnlock.unlock(), { once:true, passive:true });

            let player = new Audio();
            function isStandalone(){ return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator && navigator.standalone === true); }

            async function playNow(url){
                if (window.mode !== 'on') return;
                if (document.visibilityState !== 'visible' && !isStandalone()) return;
                await ensureAudioReady();
                const u = url + (DEV ? ((url.includes('?')?'&':'?')+'v='+Date.now()) : '');
                return new Promise((resolve) => {
                    try { player.pause(); } catch {}
                    player = new Audio(u);
                    player.muted = false; player.preload = 'auto'; player.crossOrigin = 'anonymous'; player.playsInline = true;
                    let watchdogTO;
                    const armWatchdog = () => {
                        const ms = Math.min(30000, Math.max(15000, Number.isFinite(player.duration) ? (player.duration + 0.25) * 1000 : 15000));
                        clearTimeout(watchdogTO);
                        watchdogTO = setTimeout(() => resolve(), ms);
                    };
                    player.onloadedmetadata = armWatchdog;
                    player.onended = () => { clearTimeout(watchdogTO); resolve(); };
                    player.onerror = () => { clearTimeout(watchdogTO); resolve(); };
                    armWatchdog();
                    player.play().catch(() => { clearTimeout(watchdogTO); resolve(); });
                });
            }

            const STEMS = Array.from({length:11},(_,i)=>`speed_camera_ahead_${i+1}.mp3`);
            const TAGS = [
                'your_wallet_just_got_a_little_nervous.mp3','your_best_pose_is_slow.mp3','your_brakes_called_they_are_ready_to_help.mp3',
                'Your_future_self_says_thanks.mp3','they_go_high_we_go_slow.mp3','the_only_rush_is_in_your_head.mp3',
                'the_smart_money_is_on_slowing_down.mp3','this_picture_is_not_for_the_gram.mp3','slow_and_easy_hotshot.mp3',
                'slow_is_the_new_fast.mp3','save_the_drama_for_the_drivethru.mp3','pace_yourself.mp3',
                'no_rush_no_fuss.mp3','no_need_for_a_photo_finish.mp3','less_gas_more_class.mp3',
                'give_those_brakes_a_little_love.mp3','easy_does_it.mp3','drive_like_someone_is_watching.mp3',
                'brakes_are_a_good_good_friend.mp3'
            ];
            const LOC = {
                "Fulton Street from 42nd to 43rd Ave":"fulton_street_from_42nd_to_43rd_ave.mp3",
                "Lincoln Way from 27th to 28th Ave":"lincoln_way_from_27th_to_28th_ave.mp3",
                "Geary Blvd from 7th to 8th Ave":"geary_blvd_from_7th_to_8th_ave.mp3",
                "Fulton St from 2nd Ave to Arguello Blvd":"fulton_st_from_2nd_ave_to_arguello_blvd.mp3",
                "Geary Blvd from Webster to Buchanan St":"geary_blvd_from_webster_to_buchanan_st.mp3",
                "Turk St from Van Ness Ave to Polk St":"turk_st_from_van_ness_ave_to_polk_st.mp3",
                "Bay St from Octavia to Gough St":"bay_st_from_octavia_to_gough_st.mp3",
                "Franklin St from Union to Green St":"franklin_st_from_union_to_green_st.mp3",
                "Columbus Ave from Lombard to Greenwich St":"columbus_ave_from_lombard_to_greenwich_st.mp3",
                "Broadway from Powell to Stockton St":"broadway_from_powell_to_stockton_st.mp3",
                "The Embarcadero from Green to Battery St":"the_embarcadero_from_green_to_battery_st.mp3",
                "Mission St from 8th to 9th St":"mission_st_from_8th_to_9th_st.mp3",
                "10th St from Harrison to Folsom St":"10th_st_from_harrison_to_folsom_st.mp3",
                "9th St from Bryant to Harrison St":"9th_st_from_bryant_to_harrison_st.mp3",
                "7th St from Harrison to Folsom St":"7th_st_from_harrison_to_folsom_st.mp3",
                "Harrison St from 4th to 5th St":"harrison_st_from_4th_to_5th_st.mp3",
                "Bryant St from 2nd to 3rd St":"bryant_st_from_2nd_to_3rd_st.mp3",
                "King St (EB only) from 4th to 5th St":"king_st_eb_only_from_4th_to_5th_st.mp3",
                "Market St from Danvers to Douglass St":"market_st_from_danvers_to_douglass_st.mp3",
                "Guerrero St from 19th to 20th St":"guerrero_st_from_19th_to_20th_st.mp3",
                "16th St from Bryant St to Potrero Ave":"16th_st_from_bryant_st_to_potrero_ave.mp3",
                "San Jose Ave from 29th to 30th St":"san_jose_ave_from_29th_to_30th_st.mp3",
                "Cesar Chavez St from Folsom to Harrison St":"cesar_chavez_st_from_folsom_to_harrison_st.mp3",
                "Cesar Chavez St from Indiana to Tennessee St":"cesar_chavez_st_from_indiana_to_tennessee_st.mp3",
                "3rd St (NB only) from Key to Jamestown Ave":"3rd_st_nb_only_from_key_to_jamestown_ave.mp3",
                "Bayshore Blvd (SB only) from 101 off-ramp to Tunnel Ave":"bayshore_blvd_sb_only_from_101_off_ramp_to_tunnel_ave.mp3",
                "Geneva Ave from Prague St to Brookdale Ave":"geneva_ave_from_prague_st_to_brookdale_ave.mp3",
                "Mission St from Ottawa Ave to Allison St":"mission_st_from_ottawa_ave_to_allison_st.mp3",
                "Alemany Blvd from Farragut to Naglee Ave":"alemany_blvd_from_farragut_to_naglee_ave.mp3",
                "Ocean Ave from Frida Kahlo Way to Howth St":"ocean_ave_from_frida_kahlo_way_to_howth_st.mp3",
                "San Jose Ave from Santa Ynez to Ocean Ave":"san_jose_ave_from_santa_ynez_to_ocean_ave.mp3",
                "Monterey Blvd from Edna to Congo St":"monterey_blvd_from_edna_to_congo_st.mp3",
                "Sloat Blvd from 41st Ave to Skyline Blvd":"sloat_blvd_from_41st_ave_to_skyline_blvd.mp3"
            };

            async function urlExists(url){
                try { let r = await fetch(url, { method:'HEAD', cache:'no-store' }); if (r.ok) return true; if (r.status === 405) { r = await fetch(url, { method:'GET', cache:'no-store' }); return r.ok; } return false; } catch { return false; }
            }
            async function pruneMissingAudio(){
                const okStems = [];
                for (const s of STEMS){ if (await urlExists(`${AUDIO_BASE}${s}`)) okStems.push(s); }
                STEMS.length = 0; STEMS.push(...okStems);
                const okTags = [];
                for (const t of TAGS){ if (await urlExists(`${AUDIO_BASE}${t}`)) okTags.push(t); }
                TAGS.length = 0; TAGS.push(...okTags);
                const okLoc = {};
                for (const [k,f] of Object.entries(LOC)){ if (await urlExists(`${AUDIO_BASE}${f}`)) okLoc[k]=f; }
                for (const k of Object.keys(LOC)) delete LOC[k];
                Object.assign(LOC, okLoc);
            }
            const audioManifestReady = (window.audioManifestReady = pruneMissingAudio());

            function pick(a){return a[Math.floor(Math.random()*a.length)]}
            function playLocationOnly(name){ const f=LOC[name]; if(f) playNow(`${AUDIO_BASE}${f}`); }

            /* -------- Nag -------- */
            const NAG_FIRST_MS = 120000;
            const NAG_REPEAT_MS = 15*60*1000;
            const NAG_IMAGES = [`${BASE}/images/Ad1.png`, `${BASE}/images/Ad2.png`];
            const NAG_AUDIO_URL = `${BASE}/images/audio/Ad1.mp3`;
            const nagEl = document.getElementById('nag');
            const nagImg = document.getElementById('nagImg');
            const nagCount = document.getElementById('nagCountdown');
            const nagAudio = new Audio(NAG_AUDIO_URL);
            nagAudio.preload = 'auto'; nagAudio.crossOrigin = 'anonymous';
            let nagPlaying = false, nagBuffer = null, nagBufferReady = false;

            function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
            async function ensureNagBuffer(){
                if (nagBufferReady) return nagBuffer;
                try{ const res = await fetch(`${NAG_AUDIO_URL}?v=${Date.now()}`, { cache:'force-cache' }); const ab = await res.arrayBuffer(); await AudioUnlock.unlock(); nagBuffer = await AudioUnlock.ctx.decodeAudioData(ab).catch(()=>null); nagBufferReady = true; }catch(e){ nagBufferReady = false; }
                return nagBuffer;
            }
            async function playNagWebAudio(){
                const buf = await ensureNagBuffer();
                if (!buf) throw new Error('no-buffer');
                const ctx = AudioUnlock.ctx;
                return new Promise(resolve=>{ const src = ctx.createBufferSource(); src.buffer = buf; src.connect(ctx.destination); src.onended = resolve; try { src.start(0); } catch { resolve(); } });
            }
            async function showNag(){
                if (nagPlaying) return;
                nagPlaying = true;
                const audioAllowed = (window.mode === 'on');
                if (nagImg) nagImg.src = NAG_IMAGES[Math.floor(Math.random()*NAG_IMAGES.length)];
                if (nagEl) { nagEl.style.display = 'flex'; }
                const safeClose = () => {
                    try { nagAudio.pause(); nagAudio.currentTime = 0; } catch {}
                    if (nagEl) nagEl.style.display = 'none';
                    nagPlaying = false;
                };
                try {
                    if (audioAllowed) {
                        await ensureAudioReady();
                        let t = 3; nagCount.textContent = t;
                        const iv = setInterval(()=>{ if(--t<=0) clearInterval(iv); nagCount.textContent = t; }, 1000);
                        let watchdog = setTimeout(safeClose, 12000);
                        try { await playNagWebAudio(); } catch {
                            try { nagAudio.currentTime = 0; nagAudio.load(); await nagAudio.play(); await new Promise(r => { nagAudio.addEventListener('ended', r, { once: true }); }); } catch {}
                        }
                        clearTimeout(watchdog);
                        safeClose();
                    } else {
                        setTimeout(safeClose, 2500);
                    }
                } catch { safeClose(); }
            }
            setTimeout(() => { if (!document.hidden) showNag(); }, NAG_FIRST_MS);
            let nagInt = null;
            function armNagInterval() {
                clearInterval(nagInt);
                nagInt = window.nagInt = setInterval(() => { if (!document.hidden) showNag(); }, NAG_REPEAT_MS);
            }
            document.addEventListener('visibilitychange', armNagInterval, { passive: true });
            armNagInterval();

            /* -------- Geofence alert chain -------- */
            function headingIsOk(heading, uLat, uLon, cLat, cLon, dir){
                if (typeof heading !== 'number' || !isFinite(heading)) return true;
                const dy = (cLat - uLat), dx = (cLon - uLon);
                const b = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                const d = Math.min(Math.abs(b - heading), 360 - Math.abs(b - heading));
                return d <= 100;
            }
            async function playGeofenceAlert(name) {
                showSpeedSign(SPEED_LIMITS[name]);
                try { await ensureAudioReady(); } catch {}
                (async () => {
                    try {
                        await audioManifestReady;
                        await ensureAudioReady();
                        if (window.mode === 'mute') return;
                        const f = LOC[name];
                        const seq = [`${AUDIO_BASE}${pick(STEMS)}`, f ? `${AUDIO_BASE}${f}` : null, `${AUDIO_BASE}${pick(TAGS)}`].filter(Boolean);
                        await new Promise(r => setTimeout(r, 110));
                        for (const url of seq) await playNow(url);
                    } catch (e) {}
                })();
                if (navigator.vibrate) navigator.vibrate([250, 100, 250]);
            }

            /* -------- Speed limits -------- */
            const SPEED_LIMITS = {};
            const SPEEDS_URL = `${DATA_BASE}/camera_speed_limits.json`;
            function canonicalize(n) {
                return String(n).toLowerCase().replace(/\([^)]*\)/g, ' ').replace(/[ ,]/g, ' ').replace(/\bfrom\b|\bto\b/g, ' ').replace(/^\s*the\s+/i, '').replace(/\b(street|st|avenue|ave|boulevard|blvd|road|rd|drive|dr|way)\b/gi, '').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
            }
            async function loadSpeedLimits() {
                try {
                    const rows = await fetchJSON(SPEEDS_URL);
                    const canon = new Map(rows.map(r => [canonicalize(r.name), +r.speedLimit]));
                    for (const c of cameras) { const hit = canon.get(canonicalize(c.name)); if (Number.isFinite(hit)) SPEED_LIMITS[c.name] = hit; }
                } catch (e) {}
            }
            function buildAudioUrls() {
                const urls = [`${AUDIO_BASE}beep.mp3`];
                for (const s of STEMS) urls.push(`${AUDIO_BASE}${s}`);
                for (const t of TAGS) urls.push(`${AUDIO_BASE}${t}`);
                Object.values(LOC).forEach(f => urls.push(`${AUDIO_BASE}${f}`));
                return urls;
            }
            async function preloadAudioList(urls, concurrency = 3) {
                const queue = [...urls];
                const workers = Array.from({ length: concurrency }, async () => {
                    while (queue.length) {
                        const url = queue.shift();
                        try { const a = new Audio(); a.preload = 'auto'; a.src = url; a.load(); await new Promise(r => { a.oncanplaythrough = () => r(); setTimeout(r, 1200); }); } catch (e) {}
                    }
                });
                await Promise.all(workers);
            }

            /* -------- Corridor checks + GPS -------- */
            function isInsideAnyCorridor(lat, lon){
              if (!window.turf?.booleanPointInPolygon) return false;
              try{ const pt = turf.point([lon, lat]); return corridorPolys.some(poly => { try { return turf.booleanPointInPolygon(pt, poly); } catch { return false; } }); }catch{ return false; }
            }
            const EXIT_M = 150, HYSTERESIS_M = 20, MIN_SPEED_MPS = 2.2, COOLDOWN_MS = 10000, REARM_M = DEV ? 50 : 100;
            function enterDistanceM(speedMps){
                const v = Number.isFinite(speedMps) && speedMps > 0 ? speedMps : 24.6;
                return Math.max(250, Math.min(700, Math.round(v * 18)));
            }
            const insideNow = new Set(), lastAlertAt = new Map(), lastAlertPos = new Map();
            function distM(aLat,aLon,bLat,bLon){ return distKm(aLat,aLon,bLat,bLon)*1000; }
            function markAlert(name, lat, lon){ lastAlertAt.set(name, Date.now()); lastAlertPos.set(name, { lat, lon }); }
            function passesGates(coords){
                const {accuracy,speed}=coords;
                if(!DEV && accuracy && accuracy>ACCURACY_MAX_M) return false;
                if(!DEV && typeof speed==='number' && speed<MIN_SPEED_MPS) return false;
                return true;
            }

            async function startGPS(){
                if (!termsAccepted()) { showTermsModal(()=> startGPS()); return; }
                if(!('geolocation' in navigator)) return;
                if(window.__watchId!=null) return;
                await dataReady;
                if (!map.hasLayer(userMarker)) userMarker.addTo(map);
                window.__watchId = navigator.geolocation.watchPosition(async pos=>{
                    const {latitude,longitude} = pos.coords;
                    userMarker.setLatLng([latitude, longitude]);
                    if(!passesGates(pos.coords)) return;
                    const inCorridor = isInsideAnyCorridor(latitude, longitude);
                    const nearestName = nearestCameraName(latitude, longitude);
                    const now=Date.now();
                    for(const cam of cameras){
                        const dM = distKm(latitude, longitude, cam.lat, cam.lon)*1000;
                        const nearPoint = dM <= enterDistanceM(pos.coords.speed);
                        const corridorMatch = inCorridor && (nearestName === cam.name);
                        const headingOk = headingIsOk(pos.coords.heading, latitude, longitude, cam.lat, cam.lon, cam.direction);
                        const inZone = headingOk && (nearPoint || corridorMatch);
                        const wasIn = insideNow.has(cam.name);
                        const movedEnough = (() => { const p = lastAlertPos.get(cam.name); return p ? (distM(latitude, longitude, p.lat, p.lon) > REARM_M) : true; })();
                        if(!wasIn && inZone){
                            const last = lastAlertAt.get(cam.name)||0;
                            if(now-last>COOLDOWN_MS && movedEnough){
                                await ensureAudioReady();
                                playGeofenceAlert(cam.name);
                                markAlert(cam.name, latitude, longitude);
                            }
                            insideNow.add(cam.name);
                        } else if (wasIn && !inZone && dM > (EXIT_M + HYSTERESIS_M)){
                            insideNow.delete(cam.name);
                            hideSpeedSign();
                        }
                    }
                }, err=>console.warn('Geolocation error', err), { enableHighAccuracy:true, maximumAge:500, timeout:8000 });
            }
            function stopGPS(){
                if (window.__watchId!=null){ navigator.geolocation.clearWatch(window.__watchId); window.__watchId=null; }
                try{ map.removeLayer(userMarker); }catch{}
                insideNow.clear();
                hideSpeedSign();
            }
            window.startGPS = startGPS;
            window.stopGPS = stopGPS;
        });
    </script>
</body>
</html>
