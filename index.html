<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <!-- Instant, hidden redirect to clean HTTPS apex -->
    <script>
    if (location.protocol.startsWith('http') && location.hostname !== 'localhost') {
        const domain = location.hostname.replace(/^www\./, '');
        if (location.protocol !== 'https:' || location.hostname !== domain) {
            location.replace('https://' + domain + location.pathname + location.search + location.hash);
        }
    }
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <meta name="format-detection" content="telephone=no,address=no,email=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <link rel="manifest" id="app-manifest" href="">
    <script>
        // Repo/base detection (works on speedwarn.com and github.io repo paths)
        (function () {
            const REPO = 'sf-speed-alerts';
            const path = location.pathname.replace(/\/+$/, '');
            const onRepo = location.hostname.endsWith('github.io') && path.startsWith('/' + REPO);
            let base = onRepo ? ('/' + REPO) : '';
            if (!base) {
                const parts = location.pathname.split('/');
                const idx = parts.lastIndexOf(REPO);
                if (idx > -1) base = '/' + parts.slice(1, idx + 1).join('/');
            }
            window.BASE = base;
            window.DATA_BASE = `${base}/data`;
            window.DEV = /[?&]dev=1\b/.test(location.search);
            const m = document.getElementById('app-manifest');
            if (m) m.setAttribute('href', `${base}/manifest.json`);
        })();
    </script>
    <!-- === HOTFIX: viewport + true viewport height + lift (HTTPS redirect removed) === -->
    <script>
        // Normalize viewport to prevent the "zoomed out" look
        const vp = document.querySelector('meta[name="viewport"]');
        if (vp) vp.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover');
        // Real viewport height -> CSS var (--vhpx)
        (function setVH(){
            function apply(){
                var h = Math.round((window.visualViewport?.height || window.innerHeight));
                document.documentElement.style.setProperty('--vhpx', h + 'px');
            }
            apply();
            window.addEventListener('resize', apply, {passive:true});
            window.visualViewport && window.visualViewport.addEventListener('resize', apply, {passive:true});
            window.addEventListener('orientationchange', () => setTimeout(apply, 60), {passive:true});
        })();
    </script>
    <style id="hotfix-css">
        :root{ --lift-offset: 400px; }
        /* Use real viewport height to kill the big vertical gap */
        .video-bg{ height: var(--vhpx) !important; }
        /* Pull the app content up without touching your existing spacing logic */
        .content-wrap{ margin-top: calc(var(--paid-offset-mobile) - var(--lift-offset)) !important; }
        @media (min-width:1200px){ .content-wrap{ margin-top: calc(var(--paid-offset-desktop) - var(--lift-offset)) !important; } }
        /* Map height tied to real viewport so it doesn't look desktop-zoomed */
        #map{ height: calc((var(--vhpx, 700px)) * 0.58) !important; }
        @media (max-width:1200px){ #map{ height: calc((var(--vhpx, 700px)) * 0.52) !important; } }
    </style>
    <!-- === /HOTFIX === -->
    <title>SF Speed Cameras - Alerts & Map | SpeedWarn</title>
    <meta name="description" content="Free real-time speed camera alerts for San Francisco. GPS-powered PWA shows all 33 camera locations on a live map with audio warnings. No tracking, 100% on-device.">
    <meta property="og:title" content="SpeedWarn SF - Speed Camera Alerts & Map">
    <meta property="og:description" content="Free real-time speed camera alerts for San Francisco. 33 camera locations with audio warnings.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://speedwarn.com">
    <meta name="twitter:card" content="summary">
    <link rel="canonical" href="https://speedwarn.com">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script defer src="https://unpkg.com/kdbush@4.0.2/kdbush.min.js"></script>
    <script defer src="https://unpkg.com/geokdbush@4.0.2/geokdbush.min.js"></script>
    <link rel="preload" as="audio" href="images/audio/Ad1.mp3" type="audio/mpeg">
    <link rel="preload" as="audio" href="images/audio/beep.mp3" type="audio/mpeg">
    <style>
        :root{
            --paid-offset-mobile: 220px;
            --paid-offset-desktop: 330px;
            --overlay-top: 10px;
            --shell-max: 520px;
            --overlay-paid-offset: -36px;
        }
        html, body { height:100%; }
        body{
            margin:0;
            background:#0b0b0b;
            color:#fff;
            font-family:system-ui,-apple-system,Arial;
            font-weight:600;
            display:flex;
            flex-direction:column;
            overflow-x:hidden;
        }
        .page { flex:1 0 auto; position:relative; }
        footer { flex:0 0 auto; padding:14px 0 calc(18px + env(safe-area-inset-bottom)); text-align:center; }
        .video-bg{
            position:fixed;
            left:0;
            top:0;
            width:100vw;
            height:100dvh;
            z-index:-3;
            overflow:hidden;
        }
        .video-bg video{
            position:absolute;
            inset:0;
            width:100%;
            height:100%;
            object-fit:cover;
            object-position:center center;
        }
        .overlay-layer{
            position:absolute;
            left:0;
            top:var(--overlay-top);
            width:100%;
            z-index:2;
            pointer-events:none;
        }
        .overlay-layer img{
            width:100%;
            height:auto;
            display:block;
        }
        #ovPaidImg{
            transform:translateY(var(--overlay-paid-offset));
            will-change:transform;
        }
        .content-wrap{
            position:relative;
            padding:16px 20px 24px;
            z-index:3;
            margin-top:var(--paid-offset-mobile);
        }
        @media (min-width:1200px){ .content-wrap{ margin-top:var(--paid-offset-desktop);} }
        .app-shell{ width:min(92vw, var(--shell-max)); margin:0 auto; }
        .btn-match{ line-height:1.25; padding:.55rem 1rem; font-weight:700; }
        #warmup.btn-off { background:#b02a37; border-color:#b02a37; color:#fff; }
        #warmup.btn-on { background:#198754; border-color:#198754; color:#fff; }
        #warmup.btn-mute { background:#b89b00; border-color:#b89b00; color:#111; }
        #map{ height:60vh; border:1px solid #ddd; border-radius:8px; background:rgba(255,255,255,.85); }
        @media (max-width:1200px){ #map{ height:50vh; } }
        .camera-list{ max-height:200px; overflow-y:auto; }
        @media (max-width:430px){
            #map{ height:52vh; }
            .camera-list{ max-height:180px; }
            .content-wrap{ margin-top:var(--paid-offset-mobile); }
        }
        .loc-dot{ width:14px; height:14px; border-radius:50%; background:#2a6bf4; border:2px solid #fff; box-shadow:0 0 0 6px rgba(42,107,244,.25); }
        .speed-sign {
            position:fixed;
            left:50%;
            top:12px;
            transform:translateX(-50%) translateY(-20px);
            z-index:70;
            pointer-events:none;
            opacity:0;
            transition:opacity .2s, transform .25s;
        }
        .speed-sign.show { opacity:1; transform:translateX(-50%) translateY(0); }
        .speed-sign .sign{
            background:#fff;
            color:#000;
            border:4px solid #000;
            border-radius:10px;
            width:min(46vw, 280px);
            padding:10px 14px 12px;
            box-shadow:0 10px 30px rgba(0,0,0,.35);
        }
        .speed-sign .label{ font-weight:800; letter-spacing:.06em; text-align:center; font-size:14px; margin-bottom:4px; }
        .speed-sign .value{ font-weight:900; text-align:center; font-size:clamp(56px, 16vw, 110px); line-height:1; }
        .speed-sign .capsule{ margin-top:8px; text-align:center; font-size:12px; font-weight:700; letter-spacing:.04em; color:#111; background:#eee; border-radius:999px; padding:4px 10px; display:none; }
        .speed-sign.unknown .capsule{ display:inline-block; }
        .speed-sign.fallback .sign { opacity:.85; }
        .nag-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:60; }
        .nag-wrap{ position:relative; transform:translateY(30px); }
        .nag-img{ max-width:min(90vw, 540px); border-radius:14px; box-shadow:0 25px 60px rgba(0,0,0,.55); }
        .nag-count{ position:absolute; bottom:10px; right:14px; background:rgba(0,0,0,.6); color:#fff; padding:4px 8px; border-radius:999px; font-size:12px; font-weight:800; }
        .leaflet-popup-content a{ text-decoration:none; pointer-events:none; color:inherit; }
        .dev-badge {
            position: fixed;
            left: 10px;
            bottom: 10px;
            z-index: 9999;
            background: #8b5cf6;
            color:#fff;
            padding:6px 10px;
            border-radius:999px;
            font: 700 12px/1 system-ui, -apple-system, Arial;
            box-shadow:0 6px 18px rgba(0,0,0,.35);
            display:none;
        }
        .dev-badge.show { display:inline-block; }
        .toast-container {
            position: fixed;
            right: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom));
            z-index: 10000;
        }
        /* Ensure the map sits below fixed UI */
        #map, .leaflet-container { position: relative; z-index: 1; }
        .app-ui, .logo, .onboarding, .cta, .nag { position: relative; z-index: 10; }
        /* If buttons drop below the map on mobile, pin them */
        .app-ui.fixed {
          position: fixed; left: 0; right: 0; bottom: 0;
          display: grid; gap: 8px; padding: 12px;
        }
        /* Raise background PNG/video by 12px */
        .bg-decor {
          position: fixed; inset: 0; top: -12px;
          pointer-events: none; z-index: 0;
          width: 100vw; height: 100vh; object-fit: cover; object-position: center;
        }
        /* Leaflet popups above everything else */
        .leaflet-pane.leaflet-popup-pane { z-index: 500; }
        #debugHud{position:fixed;top:8px;right:8px;background:rgba(0,0,0,.6);color:#fff;padding:8px 10px;border-radius:10px;font:12px/1.3 ui-monospace,monospace;z-index:9999}
    </style>
</head>
<body>
    <div class="video-bg" aria-hidden="true">
        <video id="bgvid" autoplay loop muted playsinline preload="auto" crossorigin="anonymous">
            <source id="bgvidSrc" src="" type="video/mp4">
        </video>
    </div>
    <div class="overlay-layer" id="overlay" aria-hidden="true">
        <picture id="overlay-paid">
            <source id="ovPaidSrcM" media="(max-width: 1200px)" srcset="">
            <img id="ovPaidImg" src="" alt="SF Speed Cameras (Paid)" decoding="async" fetchpriority="low">
        </picture>
    </div>
    <div class="page">
        <div class="content-wrap">
            <div class="app-shell">
                <div class="d-flex gap-2 align-items-center mb-3">
                    <a id="payCTA" class="btn btn-primary btn-match" href="#" aria-label="Upgrade to Pro" rel="noopener">Go Pro</a>
                    <button id="warmup" class="btn btn-match btn-off" aria-pressed="false" aria-live="polite">Sound &amp; GPS: Off</button>
                    <button id="testSound" class="btn btn-secondary btn-match" style="display:none">Test Sound</button>
                </div>
                <div id="map" class="mb-3" tabindex="-1"></div>
                <div id="list" class="card mb-3">
                    <div class="card-header">Camera Locations</div>
                    <ul class="list-group camera-list" role="listbox" aria-label="Speed camera list"></ul>
                </div>
            </div>
        </div>
    </div>
    <div id="speedSign" class="speed-sign" aria-live="polite" hidden>
        <div class="sign">
            <div class="label">SPEED LIMIT</div>
            <div class="value" id="speedLimitValue">--</div>
            <div class="capsule">SPEED CAMERA ZONE</div>
        </div>
    </div>
    <div id="nag" class="nag-backdrop" role="dialog" aria-modal="true" aria-labelledby="nagCountdown" aria-hidden="true">
        <div class="nag-wrap">
            <img id="nagImg" class="nag-img" src="" alt="Upgrade prompt" decoding="async">
            <div id="nagCountdown" class="nag-count">25</div>
        </div>
    </div>
    <div id="devBadge" class="dev-badge">DEV BUILD</div>
    <!-- Privacy Modal -->
    <div class="modal fade" id="privacyModal" tabindex="-1" aria-hidden="true" aria-labelledby="privacyTitle">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header border-0">
                    <h5 class="modal-title" id="privacyTitle">Privacy Policy & First-Time Setup</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close" id="privacyClose"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-2">We only process your location on your device to trigger nearby speed-camera alerts. We do <strong>not</strong> upload or store your GPS data on our servers.</p>
                    <ul>
                        <li>Location: used live on your phone for geofencing.</li>
                        <li>Sound: alerts play on the device (tap to enable the first time).</li>
                    </ul>
                    <p class="small mb-2">Read our full policy: <a id="privacyLink" href="/privacy.html" target="_blank" rel="noopener">Privacy Policy (opens in new tab) →</a></p>
                    <div id="privacyFallback" class="small text-secondary d-none">
                        <hr class="border-secondary">
                        <p><strong>Quick Summary:</strong> No account, no tracking, no ads networks. Location is processed locally; optional analytics (if enabled later) are anonymous and opt-in.</p>
                    </div>
                    <div class="alert alert-secondary d-flex align-items-center gap-2 py-2 px-3 mb-0">
                        <div>
                            <div class="fw-bold">Enable GPS & Sound</div>
                            <div class="small">Tap “Enable” so alerts can play and your phone can detect nearby cameras.</div>
                        </div>
                        <button id="privacyEnable" class="btn btn-success btn-sm ms-auto">Enable</button>
                        <button id="privacyLater" class="btn btn-outline-light btn-sm">Not now</button>
                    </div>
                    <div id="privacyConfirm" class="text-success fw-bold mt-2 d-none">GPS & Sound ready ✅</div>
                </div>
            </div>
        </div>
    </div>
<!-- Safety & Terms Modal -->
<div class="modal fade" id="termsModal" tabindex="-1" aria-hidden="true" aria-labelledby="termsTitle">
  <div class="modal-dialog modal-dialog-scrollable modal-lg modal-dialog-centered">
    <div class="modal-content bg-dark text-light">
      <div class="modal-header border-0">
        <h5 class="modal-title" id="termsTitle">Safety Acknowledgment & Terms</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body small">
        <div class="alert alert-warning py-2">
          <strong>Don’t interact while driving.</strong> Use hands-free audio only.
        </div>
        <p><strong>Important:</strong> This app is informational. You must obey all posted signs and laws. Alerts can be delayed, inaccurate, or unavailable.</p>
        <ul class="mb-3">
          <li>You are responsible for safe driving and legal compliance.</li>
          <li>Do not rely solely on the app; follow road signs and conditions.</li>
          <li>Speed-camera warnings may be restricted in some regions; disable where prohibited.</li>
          <li>No guarantee of accuracy, completeness, or availability.</li>
          <li>We are not liable for tickets, fines, collisions, or other losses.</li>
          <li>By continuing, you agree to the <a href="/terms.html" target="_blank" rel="noopener">Terms of Use</a> and <a href="/privacy.html" target="_blank" rel="noopener">Privacy Policy</a>.</li>
        </ul>
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="ackNotDriving">
          <label class="form-check-label" for="ackNotDriving">I will not interact with the app while the vehicle is moving.</label>
        </div>
        <div class="form-check mb-2">
          <input class="form-check-input" type="checkbox" id="ackAgree">
          <label class="form-check-label" for="ackAgree">I agree to the Safety Acknowledgment & Terms.</label>
        </div>
        <div class="text-secondary">Version <span id="termsVersionLabel"></span></div>
      </div>
      <div class="modal-footer border-0">
        <button type="button" class="btn btn-primary" id="termsAccept" disabled>Accept & Enable</button>
      </div>
    </div>
  </div>
</div>
    <!-- iOS Install Modal -->
    <div class="modal fade" id="iosInstall" tabindex="-1" aria-labelledby="iosInstallLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header border-0">
                    <h5 class="modal-title" id="iosInstallLabel">Install to Home Screen</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close" id="iosClose"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-2">For quicker launches and more reliable GPS/audio on iPhone, add this app to your Home Screen:</p>
                    <ol class="ps-3">
                        <li>Tap the <strong>Share</strong> icon in Safari’s toolbar.</li>
                        <li>Choose <strong>Add to Home Screen</strong>.</li>
                    </ol>
                    <img id="iosGuideImg" src="images/ios-add-to-home.png" alt="How to add to Home Screen on iOS" class="img-fluid rounded border border-secondary" onerror="this.classList.add('d-none')">
                </div>
                <div class="modal-footer border-0">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal" id="iosDone">Done</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Toasts -->
    <div class="toast-container p-2">
        <div id="privacyToast" class="toast text-bg-dark border-0" role="status" aria-live="polite" aria-atomic="true" data-bs-delay="6000">
            <div class="toast-body d-flex align-items-center gap-2">
                <span>Set up privacy & permissions?</span>
                <button class="btn btn-sm btn-primary" id="toastEnable">Enable</button>
                <button class="btn btn-sm btn-outline-light" id="toastLater">Later</button>
            </div>
        </div>
        <div id="installToast" class="toast text-bg-dark border-0" role="status" aria-live="polite" aria-atomic="true" data-bs-delay="6000">
            <div class="toast-body d-flex align-items-center gap-2">
                <span>Install for one-tap access?</span>
                <button class="btn btn-sm btn-primary" id="toastInstall">Add</button>
                <button class="btn btn-sm btn-outline-light" id="toastInstallLater">Later</button>
            </div>
        </div>
    </div>
    <div id="debugHud" hidden>—</div>
    <div id="ariaLive" aria-live="assertive" aria-atomic="true" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">.</div>
    <footer>
        <small>&copy; 2025–2026 SF Speed Cameras • <a href="/privacy.html" class="text-white-50" target="_blank" rel="noopener">Privacy</a> • <a href="/contact.html" class="text-white-50" target="_blank" rel="noopener">Contact</a></small>
    </footer>
    <script>
        // BASE path helper
        function withBase(url) {
          const base = window.BASE || '';
          if (/^https?:\/\//.test(url)) return url; // absolute
          if (url.startsWith('/')) return `${base}${url}`; // root-relative
          return `${base}/${url}`; // plain relative
        }
        window.addEventListener('DOMContentLoaded', () => {
            // Bring globals into local constants for convenience
            const BASE = window.BASE || '';
            const DATA_BASE = `${BASE}/data`;
            const DEV = !!window.DEV;
            const ACCURACY_MAX_M = 75;
            // --- Critical library guards (avoid hard crashes) ---
            const HAS = {
              leaflet: !!window.L,
              turf: !!window.turf,
              kdb: !!window.KDBush && !!window.geokdbush
            };
            function showFatal(msg){
              try {
                const mapBox = document.getElementById('map');
                if (mapBox) {
                  mapBox.innerHTML = '';
                  const div = document.createElement('div');
                  div.className = 'alert alert-danger';
                  div.style.margin = '12px 0';
                  div.textContent = msg + ' Try reloading.';
                  mapBox.parentNode.insertBefore(div, mapBox);
                }
              } catch {}
            }
            // If Leaflet didn’t load, bail before calling any L.*
            if (!HAS.leaflet) { showFatal('Map library failed to load.'); return; }
            // --- Safety stubs (avoid ReferenceErrors if optional pieces are missing) ---
            window.audioManifestReady = window.audioManifestReady || Promise.resolve();
            window.buildAudioUrls = window.buildAudioUrls || function(){ return []; };
            window.preloadAudioList = window.preloadAudioList || function(){};
            window.playLocationOnly = window.playLocationOnly || function(){ AudioFX.play("beep"); };
            window.applyMode = window.applyMode || function(){};
            window.stopGPS = window.stopGPS || function(){ try { window.stopCameraAlerts?.(); } catch(_){} };
            // If you later introduce a nag timer, we’ll clear it safely:
            if (typeof window.nagInt === "undefined") window.nagInt = null;
            // Fix footer & modal links to respect BASE
            document.querySelectorAll('a[href="/privacy.html"]').forEach(a => a.href = `${BASE}/privacy.html`);
            document.querySelectorAll('a[href="/contact.html"]').forEach(a => a.href = `${BASE}/contact.html`);
            document.querySelectorAll('a[href="/terms.html"]').forEach(a => a.href = `${BASE}/terms.html`);
            const plEl = document.getElementById('privacyLink');
            if (plEl) plEl.href = `${BASE}/privacy.html`;
            // Register service worker (for PWA/offline)
            const SW_VERSION = "v20"; // bump when deploying
            if ('serviceWorker' in navigator) {
              window.addEventListener('load', async () => {
                try {
                  const swUrl = `${BASE || ''}/sw.js?v=${SW_VERSION}`;
                  const reg = await navigator.serviceWorker.register(swUrl, { scope: (BASE || '/') });
                  if (reg.active) reg.update();
                  let refreshing = false;
                  navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    refreshing = true;
                    location.reload();
                  });
                } catch(e){}
              });
            }
            // Optional: show DEV badge
            document.getElementById('devBadge')?.classList.toggle('show', DEV);
            try { history.scrollRestoration = 'manual'; } catch {}
            if (location.hash) { history.replaceState(null, '', location.pathname); }
            window.addEventListener('load', () => {
                window.scrollTo(0, 0);
                if (document.activeElement) document.activeElement.blur();
            }, { once:true });
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            /* -------- Background video (autoplay-safe) -------- */
            const bg = document.getElementById('bgvid');
            const srcEl = document.getElementById('bgvidSrc');
            if (bg && srcEl) {
                bg.muted = true;
                bg.setAttribute('muted','');
                bg.setAttribute('playsinline','');
                bg.setAttribute('webkit-playsinline','');
                srcEl.src = `${BASE}/videos/background.mp4`;
                bg.load();
                const retryPlay = () => {
                    const p = bg.play();
                    if (p && p.catch) p.catch(()=> setTimeout(()=> bg.play().catch(()=>{}), 100));
                };
                bg.addEventListener('loadeddata', () => bg.removeAttribute('poster'), { once:true });
                if (!window.matchMedia || !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    retryPlay();
                }
            }
            /* -------- Overlay PNGs + dynamic spacing -------- */
            const ovM = document.getElementById('ovPaidSrcM');
            if (ovM) ovM.srcset = `${BASE}/images/Copyblockmobile_paid.png`;
            const paidImg = document.getElementById('ovPaidImg');
            if (paidImg){
                paidImg.src = `${BASE}/images/Copyblockdesktop_paid.png`;
                paidImg.addEventListener('load', () => {
                    paidImg.style.transform = `translateY(var(--overlay-paid-offset))`;
                    requestAnimationFrame(() => requestAnimationFrame(applyOverlaySpacing));
                }, { once:true });
            }
            function applyOverlaySpacing() {
                const root = document.documentElement;
                const topPx = parseFloat(getComputedStyle(root).getPropertyValue('--overlay-top')) || 0;
                const paidOffset = parseFloat(getComputedStyle(root).getPropertyValue('--overlay-paid-offset')) || 0; // negative
                const ph = paidImg?.getBoundingClientRect().height || 0;
                const measured = ph ? Math.round(ph + topPx + paidOffset) : 220;
                const IS_IOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
                const anchor = IS_IOS ? Math.round((window.visualViewport?.height || window.innerHeight) * 0.46) : 0;
                const mt = Math.max(measured, anchor);
                root.style.setProperty('--paid-offset-mobile', `${mt}px`);
                root.style.setProperty('--paid-offset-desktop', `${Math.max(mt, 330)}px`);
                if (DEV) console.info('[DEV] overlay h:', ph, 'measured:', measured, 'anchor:', anchor, 'margin-top:', mt);
            }
            applyOverlaySpacing();
            let ovRzT;
            const reflowOverlay = () => {
                clearTimeout(ovRzT);
                ovRzT = setTimeout(applyOverlaySpacing, 100);
            };
            addEventListener('resize', reflowOverlay, { passive:true });
            addEventListener('orientationchange', reflowOverlay);
            if (window.visualViewport) window.visualViewport.addEventListener('resize', reflowOverlay, { passive:true });
            /* -------- Stripe -------- */
            const STRIPE_URL = "https://buy.stripe.com/eVq4gA1ra1ptdAT1ZQfbq01";
            const payCTA = document.getElementById('payCTA');
            if (payCTA) payCTA.addEventListener('click', (e)=>{
                e.preventDefault();
                window.open(STRIPE_URL, '_blank', 'noopener,noreferrer');
            });
            /* Fit BG container height (debounced) */
            // Background sizing handled via --vhpx; no extra JS needed.
            /* -------- Debug badge + fetch wrapper -------- */
            function showDebug(msg, isErr=false){
                let el = document.getElementById('debugBadge');
                if (!el){
                    el = document.createElement('div');
                    el.id = 'debugBadge';
                    el.setAttribute('role','status');
                    el.style.cssText = 'position:fixed;right:10px;bottom:10px;z-index:9999;padding:8px 10px;border-radius:8px;background:#111;color:#fff;font:600 12px system-ui;opacity:.9';
                    document.body.appendChild(el);
                }
                el.style.background = isErr ? '#8b0000' : '#111';
                el.textContent = msg;
            }
            window.addEventListener('error', e => showDebug(e.message, true));
            window.addEventListener('unhandledrejection', e => showDebug(String(e.reason), true));
            async function fetchJSON(url){
                try{
                    const isDev = !!window.DEV;
                    const finalUrl = isDev ? `${url}${url.includes('?') ? '&' : '?'}v=${Date.now()}` : url;
                    const r = await fetch(finalUrl, { cache: isDev ? 'no-store' : 'default' });
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return await r.json();
                }catch(e){
                    console.warn('Fetch failed', url, e);
                    showDebug(`Failed: ${url.split('/').pop()}`, true);
                    throw e;
                }
            }
            /* -------- Map -------- */
            let map, userMarker;
            const poleLayer = L.layerGroup();
            const areaLayer = L.layerGroup();
            const corridorPolys = []; // polygons for in-zone checks
            function initMap(){
                map = L.map('map',{ zoomControl:true }).setView([37.7749,-122.4194],12);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap' }).addTo(map);
                poleLayer.addTo(map);
                areaLayer.addTo(map);
                const ul = document.querySelector('.camera-list');
                ul?.setAttribute('role','listbox');
                const dot = L.divIcon({ className:'loc-dot' });
                userMarker = L.marker([37.7749,-122.4194],{icon:dot});
                window.map = map;
            }
            /* -------- Audio unlock + helpers -------- */
            (() => {
              const SFX = {
                manifest: {
                  beep: "images/audio/beep.mp3",
                  nag: "images/audio/Ad1.mp3"
                  // add more ids->files here
                },
                ctx: null,
                buffers: new Map(),
                unlocked: false,
                loading: null,
              };
              function ensureCtx() {
                // If AudioUnlock is already our own object, don't read its ctx getter (avoids recursion).
                const injected = (window.AudioUnlock && window.AudioUnlock !== window.AudioFX && window.AudioUnlock.ctx) || null;
                if (injected) { SFX.ctx = injected; return injected; }
                if (!SFX.ctx) SFX.ctx = new (window.AudioContext || window.webkitAudioContext)();
                return SFX.ctx;
              }
              async function loadAll() {
                if (SFX.loading) return SFX.loading;
                const ctx = ensureCtx();
                SFX.loading = Promise.all(Object.entries(SFX.manifest).map(async ([id, url]) => {
                  const res = await fetch(withBase(url), { cache: "reload" }).catch(()=>null);
                  if (!res || !res.ok) return;
                  const arr = await res.arrayBuffer();
                  const buf = await ctx.decodeAudioData(arr).catch(()=>null);
                  if (buf) SFX.buffers.set(id, buf);
                }));
                return SFX.loading;
              }
              async function unlock() {
                if (SFX.unlocked) return;
                const ctx = ensureCtx();
                if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
                // play a silent buffer to satisfy iOS
                const node = ctx.createBufferSource();
                node.buffer = ctx.createBuffer(1, 1, 22050);
                node.connect(ctx.destination);
                node.start(0);
                SFX.unlocked = true;
                await loadAll();
              }
              async function play(id, {gain=1.0, rate=1.0} = {}) {
                try {
                  // Respect global mute and background restrictions by default.
                  if (window.mode !== 'on') return;
                  const standalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator && navigator.standalone === true);
                  if (document.visibilityState !== 'visible' && !standalone) return;
                  const ctx = ensureCtx();
                  if (ctx.state === "suspended") { try { await ctx.resume(); } catch(e){} }
                  if (!SFX.buffers.size) await loadAll();
                  const buf = SFX.buffers.get(id);
                  if (!buf) return;
                  const src = ctx.createBufferSource();
                  const g = ctx.createGain();
                  src.buffer = buf; src.playbackRate.value = rate;
                  src.connect(g); g.gain.value = gain; g.connect(ctx.destination);
                  src.start(0);
                } catch(e){ /* swallow */ }
              }
              // public
              window.AudioFX = {
                unlock, play, loadAll,
                get ctx(){ return ensureCtx(); }
              };
              // Back-compat alias so existing calls to AudioUnlock keep working
              window.AudioUnlock = window.AudioUnlock || window.AudioFX;
              // auto-unlock on first tap/click
              ["pointerdown","touchstart","click"].forEach(evt=>{
                window.addEventListener(evt, unlock, { once: true, passive: true });
              });
            })();
            window.addEventListener("load", () => {
              // Passive warmup; AudioFX.loadAll() finalizes after unlock
              setTimeout(()=>AudioFX.loadAll(), 1000);
            });
            /* -------- Poles & Corridors -------- */
            const CORRIDORS_URL = `${DATA_BASE}/corridors.json`;
            const POLES_URL = `${DATA_BASE}/poles.json`;
            const POLY_STYLE = { stroke:false, weight:0, color:'#1e88e5', opacity:0, fillColor:'#1e88e5', fillOpacity:0.18 };
            function toRad(d){return d*Math.PI/180}
            function distKm(aLat,aLon,bLat,bLon){
                const R=6371,dLat=toRad(bLat-aLat),dLon=toRad(bLon-aLon);
                const s=Math.sin(dLat/2)**2+Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*Math.sin(dLon/2)**2;
                return R*2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s));
            }
            function nearestCameraName(lat, lon){
                let best=null, bestD=Infinity;
                for (const c of cameras){
                    const d = distKm(lat, lon, c.lat, c.lon);
                    if (d < bestD){ bestD = d; best = c.name; }
                }
                return best;
            }
            function pushCorridorPolys(geo){
                if (!geo) return;
                const pushOne = (feat) => {
                    const t = feat?.geometry?.type;
                    if (t === 'Polygon' || t === 'MultiPolygon') corridorPolys.push(feat);
                };
                if (geo.type === 'Feature') pushOne(geo);
                else if (geo.type === 'FeatureCollection') (geo.features || []).forEach(pushOne);
            }
            function normalizeToPolygons(fc) {
              if (!window.turf) return (fc && fc.type === 'FeatureCollection') ? fc : { type:'FeatureCollection', features: [] };
              const out = [];
              for (const f of (fc?.features||[])) {
                const t = f?.geometry?.type || '';
                if (t.includes('Line')) {
                  try {
                    const buf = turf.buffer(f, 0.02, { units: 'kilometers' });
                    if (buf?.type === 'FeatureCollection') (buf.features||[]).forEach(bf => out.push(bf));
                    else if (buf) out.push(buf);
                  } catch {}
                } else if (t === 'Polygon' || t === 'MultiPolygon') {
                  out.push(f);
                }
              }
              return { type:'FeatureCollection', features: out };
            }
            function addCorridors(fc){
                const layer = L.geoJSON(fc, {
                    style: POLY_STYLE,
                    onEachFeature: (feat, l) => {
                        const nm = feat.properties?.CORRIDOR || feat.properties?.Name || feat.properties?.Segment || feat.properties?.name || 'Approach Area';
                        l.bindPopup(nm);
                    }
                }).addTo(areaLayer);
                pushCorridorPolys(fc);
                return layer;
            }
            function polyToMultiLine(feature){
                try {
                    const out = turf.polygonToLine(feature);
                    if (!out) return null;
                    if (out.type === 'Feature' && /LineString/i.test(out.geometry?.type)) return out;
                    if (out.type === 'Feature' && out.geometry?.type === 'MultiLineString') return out;
                    if (out.type === 'FeatureCollection') {
                        const lines = out.features
                            .map(f => f.geometry)
                            .filter(g => g && /LineString/i.test(g.type))
                            .map(g => g.coordinates);
                        if (lines.length) return turf.multiLineString(lines);
                    }
                } catch {}
                return null;
            }
            function snapToPolygonEdge(lng, lat, polyFeature){
                try{
                    const pt = turf.point([lng, lat]);
                    const line = polyToMultiLine(polyFeature) || (polyFeature?.geometry?.coordinates?.[0] ? turf.lineString(polyFeature.geometry.coordinates[0]) : null);
                    if (!line) return [lat, lng];
                    const snapped = turf.nearestPointOnLine(line, pt, { units: 'kilometers' });
                    const [slng, slat] = snapped.geometry.coordinates;
                    return [slat, slng];
                }catch{ return [lat, lng]; }
            }
            function filterCorridorsToPoles(corridorsFC, polesFC){
              if (!window.turf) {
                return {
                  fc: {
                    type:'FeatureCollection',
                    features: (corridorsFC.features || []).filter(f => {
                      const t = f.geometry?.type; return t === 'Polygon' || t === 'MultiPolygon';
                    })
                  },
                  corridorForPole: new Map()
                };
              }
                const polys = (corridorsFC.features || []).filter(f => {
                    const t = f.geometry?.type;
                    return t === 'Polygon' || t === 'MultiPolygon';
                });
                const centers = polys.map((f, i) => ({ i, c: turf.centerOfMass(f) }));
                const poles = (polesFC.features || []).filter(f => f.geometry?.type === 'Point');
                const picked = new Set();
                const selected = [];
                const corridorForPole = new Map();
                for (const pole of poles){
                    const name = pole.properties?.name || `pole_${selected.length+1}`;
                    const pt = turf.point(pole.geometry.coordinates);
                    const ranked = centers
                        .map(({i, c}) => ({ i, d: turf.distance(pt, c, { units: 'kilometers' }) }))
                        .sort((a,b)=>a.d-b.d);
                    const choice = ranked.find(r => !picked.has(r.i))?.i ?? ranked[0]?.i;
                    if (choice != null){
                        picked.add(choice);
                        const poly = polys[choice];
                        selected.push(poly);
                        corridorForPole.set(name, poly);
                    }
                }
                return { fc: { type:'FeatureCollection', features: selected }, corridorForPole };
            }
            function addPoleMarkers(fc, corridorForPole){
                const camIcon = L.icon({
                    iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28"><circle cx="14" cy="14" r="10" fill="#d62828" stroke="white" stroke-width="3"/></svg>'),
                    iconSize:[28,28],
                    iconAnchor:[14,14]
                });
                const feats = (fc.features||[]).filter(f=>{
                    const g = f.geometry || {};
                    if (g.type !== 'Point' || !Array.isArray(g.coordinates)) return false;
                    const [x,y]=g.coordinates;
                    return x>-124&&x<-121&&y>37&&y<38;
                });
                const ul = document.querySelector('.camera-list');
                if (ul) ul.innerHTML = '';
                const latlngs=[];
                for (const f of feats){
                    const [lng,lat]=f.geometry.coordinates;
                    const name = f.properties?.name || 'Speed Camera';
                    const poly = corridorForPole?.get(name);
                    const [snapLat, snapLng] = poly ? snapToPolygonEdge(lng, lat, poly) : [lat, lng];
                    const m = L.marker([snapLat, snapLng],{icon:camIcon}).addTo(poleLayer);
                    const div = document.createElement('div');
                    div.textContent = name;
                    m.bindPopup(div);
                    m.on('click', ()=>{
                        if (LOC[name]) playLocationOnly(name);
                    });
                    latlngs.push([snapLat, snapLng]);
                    if (ul){
                        const li=document.createElement('li');
                        li.className='list-group-item';
                        li.textContent=name;
                        li.setAttribute('role','option');
                        li.setAttribute('tabindex','0');
                        li.addEventListener('click',()=>{
                            map.setView([snapLat,snapLng],15);
                            if(LOC[name]) playLocationOnly(name);
                        });
                        li.addEventListener('keydown', (e)=>{
                            if(e.key==='Enter'||e.key===' '){
                                e.preventDefault();
                                li.click();
                            }});
                        ul.appendChild(li);
                    }
                }
                if(latlngs.length){
                    map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
                }
            }
            /* -------- Speed sign (fallback + timers) -------- */
            let speedSignTO=null;
            const DEFAULT_LIMIT = 30;
            const SPEED_SIGN_MS = DEV ? 2000 : 5000;
            function showSpeedSign(limit){
                const box = document.getElementById('speedSign');
                const val = document.getElementById('speedLimitValue');
                if (!box || !val) return;
                const usingFallback = !Number.isFinite(limit);
                const toShow = usingFallback ? DEFAULT_LIMIT : limit;
                box.classList.remove('fallback','unknown');
                box.classList.toggle('fallback', usingFallback);
                box.classList.toggle('unknown', usingFallback);
                val.textContent = String(toShow);
                box.hidden = false;
                box.classList.add('show');
                if (window.mode === 'on') AudioFX.play("beep");
                clearTimeout(speedSignTO);
                speedSignTO = setTimeout(hideSpeedSign, SPEED_SIGN_MS);
            }
            function hideSpeedSign(){
                const box=document.getElementById('speedSign');
                if(!box) return;
                box.classList.remove('show');
                clearTimeout(speedSignTO);
                speedSignTO=null;
                setTimeout(()=>{box.hidden=true;},200);
            }
            /* -------- Gates / timing -------- */
            (function(){
              const hasTurf = !!window.turf;
              const CFG = {
                baseEnterM: 180, // minimum entry radius
                baseExitM: 240, // minimum exit radius (>= baseEnterM)
                fovDeg: 60, // approach cone width
                cooldownMs: 2*60*1000, // per-camera cooldown
                globalCooldownMs: 3000, // global "no more than 1 alert per 3s"
                accuracyMaxM: ACCURACY_MAX_M // ignore alerts if GPS accuracy worse than this
              };
              let lastGlobalAlert = 0;
              const state = new Map(); // cameraId -> { inZone, lastFired }
              // Distance in meters: Turf if available, else Haversine
              const meters = hasTurf
                ? (a,b)=>turf.distance(a,b,{units:"kilometers"})*1000
                : (a,b)=>{
                    const [lngA, latA] = a.geometry.coordinates;
                    const [lngB, latB] = b.geometry.coordinates;
                    const R=6371, dLat=(latB-latA)*Math.PI/180, dLon=(lngB-lngA)*Math.PI/180;
                    const s=Math.sin(dLat/2)**2+Math.cos(latA*Math.PI/180)*Math.cos(latB*Math.PI/180)*Math.sin(dLon/2)**2;
                    return R*2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s))*1000;
                  };
              // Bearing degrees: Turf if available, else math
              const bearing = hasTurf
                ? (a,b)=>turf.bearing(a,b)
                : (a,b)=>{
                    const [lngA, latA] = a.geometry.coordinates.map(v=>v*Math.PI/180);
                    const [lngB, latB] = b.geometry.coordinates.map(v=>v*Math.PI/180);
                    const y = Math.sin(lngB-lngA)*Math.cos(latB);
                    const x = Math.cos(latA)*Math.sin(latB)-Math.sin(latA)*Math.cos(latB)*Math.cos(lngB-lngA);
                    const deg = (Math.atan2(y,x)*180/Math.PI + 360) % 360;
                    return deg;
                  };
              const diff = (a,b)=>Math.min((360+((a-b)%360))%360,(360+((b-a)%360))%360);
              function dynamicRadii(speedMps){
                const enter = Math.max(CFG.baseEnterM, (speedMps||0)*10);
                const exit = Math.max(CFG.baseExitM, enter + 60);
                return { ENTER_M: enter, EXIT_M: exit };
              }
              function facingOK(cam, lastPos, pos){
                // If no Turf and no previous point, or facing unknown, allow.
                const dir = String(cam.facing || cam.properties?.facing || "BOTH").toUpperCase();
                if (dir === "BOTH") return true;
                if (!pos) return true;
                const here = { type:"Feature", geometry:{ type:"Point", coordinates:[pos.coords.longitude, pos.coords.latitude] } };
                const prev = lastPos
                  ? { type:"Feature", geometry:{ type:"Point", coordinates:[lastPos.coords.longitude, lastPos.coords.latitude] } }
                  : here;
                const drive = bearing(prev, here);
                const nominal = ({
                  N:0, NB:0, NE:45,
                  E:90, EB:90, SE:135,
                  S:180, SB:180, SW:225,
                  W:270, WB:270, NW:315
                })[dir];
                if (nominal == null) return true;
                return diff(drive, nominal) <= (CFG.fovDeg/2);
              }
              window.shouldAlertCameraPro = function(cam, lastPos, pos, speedMps){
                if (pos?.coords?.accuracy && pos.coords.accuracy > CFG.accuracyMaxM) return false;
                const id = cam.id ?? cam.pole_id ?? cam.name ?? JSON.stringify(cam.geometry?.coordinates);
                if (!id) return false;
                const here = { type:"Feature", geometry:{ type:"Point", coordinates:[pos.coords.longitude, pos.coords.latitude] } };
                const there = { type:"Feature", geometry:{ type:"Point", coordinates: cam.geometry?.coordinates ?? cam.coords } };
                const d = meters(here, there);
                const { ENTER_M, EXIT_M } = dynamicRadii(speedMps);
                let s = state.get(id) || { inZone:false, lastFired:0 };
                if (!s.inZone && d <= ENTER_M) s.inZone = true;
                if (s.inZone && d >= EXIT_M) s.inZone = false;
                const now = Date.now();
                const cooled = (now - s.lastFired) > CFG.cooldownMs;
                const globalCooled = (now - lastGlobalAlert) > CFG.globalCooldownMs;
                const okFacing = facingOK(cam, lastPos, pos);
                const fire = s.inZone && cooled && globalCooled && okFacing;
                if (fire) { s.lastFired = now; lastGlobalAlert = now; }
                state.set(id, s);
                return fire;
              };
              window.__alertState = ()=>({ size: state.size });
              if (DEV) window.__alertCFG = CFG;
            })();
            /* -------- Geolocation watch loop + nearest-camera alerting -------- */
            (function(){
              // --- config ---------------------------------------------------------------
              const OPTS = {
                throttleMs: 800, // reduce CPU/GPS spam
                highAcc: true,
                maxAgeMs: 4000,
                timeoutMs: 10000,
                userMarker: { radius: 6 }, // Leaflet circleMarker style
                nearestSearchLimit: 1500, // only consider cams within 1500 m, else skip alerting
                drawUserTrail: false // set true to visualize your path
              };
              // --- private state --------------------------------------------------------
              let watchId = null;
              let lastPos = null;
              let lastTick = 0;
              let userDot = null;
              let userTrail = null;
              let camLayer = null; // optional highlight of nearest
              let currentNearestId = null;
              // Normalize a camera Feature into a plain object used by shouldAlertCamera/showSpeedLimitPopup
              function normalizeCamera(feature){
                if (!feature) return null;
                const p = feature.properties || {};
                const id = p.id ?? p.pole_id ?? p.name ?? feature.id ?? JSON.stringify(feature.geometry?.coordinates);
                const facing = (p.direction ?? p.facing ?? "BOTH");
                const speedLimit = getCameraSpeedLimit(feature);
                return {
                  id, facing, speedLimit,
                  properties: p,
                  geometry: feature.geometry
                };
              }
              // Find nearest camera to current position (linear scan; fast enough for ~hundreds of poles)
              function findNearestCamera(pos, features){
                if (!features || !features.length) return { feature:null, distM: Infinity, idx:-1 };
                const hereLat = pos.coords.latitude, hereLng = pos.coords.longitude;
                let best = { feature:null, distM: Infinity, idx:-1 };
                for (let i=0; i<features.length; i++){
                  const f = features[i];
                  const [lng, lat] = (f.geometry && f.geometry.coordinates) || [];
                  if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
                  const d = distKm(hereLat, hereLng, lat, lng) * 1000; // uses your distKm()
                  if (d < best.distM) best = { feature:f, distM:d, idx:i };
                }
                return best;
              }
              // Update (or create) the user marker and trail
              function renderUser(pos){
                const lat = pos.coords.latitude, lng = pos.coords.longitude;
                if (!userDot){
                  userDot = L.circleMarker([lat, lng], { radius: OPTS.userMarker.radius, weight:2, color:'#0af', fillColor:'#0af', fillOpacity:0.7 });
                  userDot.addTo(map);
                } else {
                  userDot.setLatLng([lat, lng]);
                }
                if (OPTS.drawUserTrail){
                  if (!userTrail) userTrail = L.polyline([[lat,lng]], { opacity: 0.5 }).addTo(map);
                  else userTrail.addLatLng([lat,lng]);
                }
              }
              // Optional: show the nearest camera as a small highlight marker
              function renderNearestHighlight(feature){
                if (!feature) { if (camLayer) { map.removeLayer(camLayer); camLayer = null; } return; }
                const [lng, lat] = feature.geometry.coordinates;
                if (!camLayer){
                  camLayer = L.circleMarker([lat, lng], { radius:5, color:'#ff0', weight:2, fillOpacity:0.2 });
                  camLayer.addTo(map);
                } else camLayer.setLatLng([lat, lng]);
              }
              // Main tick per geolocation update
              function onPosition(pos, camerasFC){
                if (!DEV && pos?.coords?.accuracy && pos.coords.accuracy > ACCURACY_MAX_M) {
                  lastPos = pos; // still update trail/lastPos if you wish
                  return; // skip alerting when GPS is too noisy
                }
                const now = Date.now();
                if (now - lastTick < OPTS.throttleMs) return;
                lastTick = now;
                renderUser(pos);
                const NEAR = (window.findNearestCameraFast || findNearestCamera);
                const { feature, distM } = NEAR(pos, camerasFC.features || []);
                const camObj = normalizeCamera(feature);
                // Debug overlay (SNIPPET 12)
                const HUD = document.getElementById('debugHud');
                window.updateDebug = (o={})=>{
                  HUD.hidden = false;
                  HUD.textContent = JSON.stringify(o, null, 0);
                };
                if (window.updateDebug) {
                  const mph = (pos.coords.speed != null && isFinite(pos.coords.speed))
                    ? Math.round(pos.coords.speed * 2.23694) : null;
                  window.updateDebug({
                    distM: feature ? Math.round(distM) : null,
                    nearestId: camObj?.id ?? null,
                    speedMph: mph,
                  });
                }
                // Skip if nothing near enough (avoids random popups far away)
                if (!feature || distM > OPTS.nearestSearchLimit) {
                  renderNearestHighlight(null);
                  lastPos = pos;
                  return;
                }
                renderNearestHighlight(feature);
                // Decide if we should alert based on approach cone, cooldown, hysteresis
                const fired = (window.shouldAlertCameraPro || window.shouldAlertCamera)(camObj, lastPos, pos, pos.coords.speed);
                if (fired) {
                  // Show popup + beep (SNIPPET 2 also beeps on popupopen)
                  showSpeedLimitPopup(camObj);
                  // Optionally play a longer nag VO when entering the zone (uncomment if desired)
                  // const limit = getCameraSpeedLimit(camObj);
                  // if (limit !== null) AudioFX.play("nag", { gain: 0.9 });
                }
                currentNearestId = camObj?.id ?? null;
                lastPos = pos;
              }
              function onError(err){
                // Keep it quiet but available for quick diagnosis
                console.warn("Geolocation error:", err?.code, err?.message);
              }
              // Public start/stop
              function startCameraAlerts(camerasGeoJSON = window.CAMERAS_GEOJSON){
                if (!('geolocation' in navigator)) { console.warn("Geolocation not supported."); return { stop(){} }; }
                if (!camerasGeoJSON || !camerasGeoJSON.features) { console.warn("Missing CAMERAS_GEOJSON FeatureCollection."); return { stop(){} }; }
                // Warm-up Audio (SNIPPET 9 ensures load post-unlock)
                if (window.AudioFX?.loadAll) AudioFX.loadAll();
                const opts = {
                  enableHighAccuracy: OPTS.highAcc,
                  maximumAge: OPTS.maxAgeMs,
                  timeout: OPTS.timeoutMs
                };
                // Start watching
                if (watchId !== null) navigator.geolocation.clearWatch(watchId);
                watchId = navigator.geolocation.watchPosition(
                  (pos)=>onPosition(pos, camerasGeoJSON),
                  onError,
                  opts
                );
                return { stop: stopCameraAlerts };
              }
              function stopCameraAlerts(){
                if (watchId !== null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
                if (camLayer) { map.removeLayer(camLayer); camLayer = null; }
                // Keep userDot/userTrail so the UI persists after stop; remove if you prefer:
                // if (userDot) { map.removeLayer(userDot); userDot = null; }
                // if (userTrail) { map.removeLayer(userTrail); userTrail = null; }
              }
              // expose
              window.startCameraAlerts = startCameraAlerts;
              window.stopCameraAlerts = stopCameraAlerts;
              // Optional: auto-start if you have a global CAMERAS_GEOJSON ready
              // document.addEventListener("DOMContentLoaded", ()=> {
              // if (window.CAMERAS_GEOJSON) startCameraAlerts(window.CAMERAS_GEOJSON);
              // });
            })();
            /* -------- Load data/poles.json -> CAMERAS_GEOJSON, then start alerts -------- */
            (function(){
              async function loadCamerasAndStart({
                url = 'data/poles.json',
                drawPoles = true,
                autoStart = true
              } = {}){
                try {
                  const res = await fetch(withBase(url), { cache: 'reload' });
                  if (!res.ok) throw new Error(`HTTP ${res.status}`);
                  const raw = await res.json();
                  // Normalize to FeatureCollection
                  const fc = (raw && raw.type === 'FeatureCollection')
                    ? raw
                    : { type: 'FeatureCollection', features: Array.isArray(raw) ? raw : [] };
                  // Clean features: id, facing, speedLimit, coords as [lng,lat]
                  const features = (fc.features || []).map((f, i) => {
                    const g = f?.geometry || {};
                    let coords = g.coordinates;
                    if (!coords || coords.length !== 2) return null;
                    // If likely [lat,lng], flip to [lng,lat]
                    const [a,b] = coords;
                    const looksLatLng = Math.abs(a) <= 90 && Math.abs(b) <= 180;
                    const looksLngLat = Math.abs(a) <= 180 && Math.abs(b) <= 90;
                    if (looksLatLng && !looksLngLat) coords = [b, a];
                    const p = f.properties || {};
                    const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                    const facing = String(p.direction ?? p.facing ?? 'BOTH').toUpperCase();
                    const speedLimit = getCameraSpeedLimit(f);
                    return {
                      type: 'Feature',
                      id,
                      properties: { ...p, id, facing, speedLimit },
                      geometry: { type: 'Point', coordinates: coords }
                    };
                  }).filter(Boolean);
                  window.CAMERAS_GEOJSON = { type: 'FeatureCollection', features };
                  if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(features);
                  // Optional visualization (Snippet 5)
                  if (drawPoles && typeof window.addPolesAndApproaches === 'function') {
                    window.addPolesAndApproaches(window.CAMERAS_GEOJSON, { offsetMeters: 5 });
                  }
                  // Start alerts (Snippet 13)
                  if (autoStart && typeof window.startCameraAlerts === 'function') {
                    window.startCameraAlerts(window.CAMERAS_GEOJSON);
                  }
                  console.log(`Loaded ${features.length} cameras from ${url}`);
                } catch (err) {
                  // try Cache API
                  try {
                    if ('caches' in window) {
                      const match = await caches.match(withBase(url));
                      if (match) {
                        const raw = await match.json();
                        const fc = (raw && raw.type === 'FeatureCollection')
                          ? raw
                          : { type: 'FeatureCollection', features: Array.isArray(raw) ? raw : [] };
                        // Normalize features like happy path
                        const features = (fc.features || []).map((f, i) => {
                          const g = f?.geometry || {};
                          let coords = g.coordinates;
                          if (!coords || coords.length !== 2) return null;
                          const [a,b] = coords;
                          const looksLatLng = Math.abs(a) <= 90 && Math.abs(b) <= 180;
                          const looksLngLat = Math.abs(a) <= 180 && Math.abs(b) <= 90;
                          if (looksLatLng && !looksLngLat) coords = [b, a];
                          const p = f.properties || {};
                          const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                          const facing = String(p.direction ?? p.facing ?? 'BOTH').toUpperCase();
                          const speedLimit = getCameraSpeedLimit(f);
                          return {
                            type: 'Feature',
                            id,
                            properties: { ...p, id, facing, speedLimit },
                            geometry: { type: 'Point', coordinates: coords }
                          };
                        }).filter(Boolean);
                        window.CAMERAS_GEOJSON = { type: 'FeatureCollection', features };
                        if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(features);
                        if (drawPoles && window.addPolesAndApproaches) {
                          window.addPolesAndApproaches(window.CAMERAS_GEOJSON, { offsetMeters: 5 });
                        }
                        if (autoStart !== false && window.startCameraAlerts) {
                          window.startCameraAlerts(window.CAMERAS_GEOJSON);
                        }
                        console.warn('Loaded cameras from Cache API fallback:', url);
                        return;
                      }
                    }
                  } catch(_) {}
                  console.error('Failed to load cameras (network + cache fallback failed).');
                }
              }
              // Expose for manual use
              window.loadCamerasAndStart = loadCamerasAndStart;
            })();
            /* -------- Spatial index for fast nearest-camera lookups (KDBush) -------- */
            (function(){
              let __idx = null, __pts = null;
              window.buildCameraIndex = function(features){
                if (!HAS.kdb) return null;
                __pts = (features||[]).map((f,i)=>{
                  const [lng,lat] = f.geometry.coordinates;
                  return { i, lng, lat };
                });
                __idx = new KDBush(__pts, p=>p.lng, p=>p.lat, 64, Float64Array);
                return __idx;
              };
              window.findNearestCameraFast = function(pos, features){
                if (!HAS.kdb || !__idx || !__pts) return { feature:null, distM: Infinity, idx:-1 };
                const lng = pos.coords.longitude, lat = pos.coords.latitude;
                const nearest = geokdbush.around(__idx, lng, lat, 1)[0];
                if (!nearest) return { feature:null, distM: Infinity, idx:-1 };
                const f = features[nearest.i];
                const distM = turf
                  ? turf.distance(turf.point([lng,lat]), turf.point(f.geometry.coordinates), {units:"kilometers"})*1000
                  : (function distKm(aLat,aLon,bLat,bLon){const R=6371, dLat=(bLat-aLat)*Math.PI/180, dLon=(bLon-aLon)*Math.PI/180; const s=Math.sin(dLat/2)**2+Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*Math.sin(dLon/2)**2; return R*2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s));})(lat,lng,f.geometry.coordinates[1],f.geometry.coordinates[0])*1000;
                return { feature:f, distM, idx:nearest.i };
              };
            })();
            /* -------- visualize poles and 120m approach rays -------- */
            function addPolesAndApproaches(geojson, {offsetMeters=5}={}){
              if (!window.turf) return null;
              const approachPoleLayer = L.layerGroup().addTo(map);
              const approachLayer = L.layerGroup().addTo(map);
              geojson.features.forEach(f=>{
                const coords = f.geometry.coordinates; // [lng, lat]
                const pt = turf.point(coords);
                const dir = (f.properties?.facing || "BOTH").toUpperCase();
                const bearingMap = {
                  N:0, NB:0, NE:45,
                  E:90, EB:90, SE:135,
                  S:180, SB:180, SW:225,
                  W:270, WB:270, NW:315
                };
                // Offset 5m to the right of the approach vector (visual “roadside”)
                const bearingDeg = bearingMap[dir] ?? 90; // default East if BOTH
                const rightDeg = (bearingDeg + 90) % 360;
                const offsetPt = turf.destination(pt, offsetMeters/1000, rightDeg, {units:"kilometers"});
                const [lng, lat] = offsetPt.geometry.coordinates;
                L.circleMarker([lat,lng], {radius:4, weight:1, opacity:0.9, fillOpacity:0.9})
                  .addTo(approachPoleLayer);
                if (dir !== "BOTH") {
                  const back = turf.destination(pt, 0.12, (bearingDeg+180)%360, {units:"kilometers"});
                  const line = L.polyline([
                    [back.geometry.coordinates[1], back.geometry.coordinates[0]],
                    [lat, lng]
                  ], {dashArray:"4,4", opacity:0.7}).addTo(approachLayer);
                }
              });
              return { approachPoleLayer, approachLayer };
            }
            window.addPolesAndApproaches = addPolesAndApproaches;
            /* -------- call this instead of directly creating the popup -------- */
            function showSpeedLimitPopup(cam){
              const limit = getCameraSpeedLimit(cam);
              const html = limit ? `<b>Speed limit: ${limit} mph</b>` : `<b>Speed camera</b>`;
              try {
                const coords = cam?.geometry?.coordinates;
                if (Array.isArray(coords) && coords.length === 2 && isFinite(coords[0]) && isFinite(coords[1])) {
                  L.popup({autoClose:true, closeOnClick:true})
                    .setLatLng([coords[1], coords[0]])
                    .setContent(html)
                    .openOn(map);
                }
              } catch {}
              if (window.mode === 'on') AudioFX.play("beep");
              const txt = limit ? `Speed limit ${limit} miles per hour` : `Speed camera ahead`;
              try{ window.announce?.(txt); }catch(e){}
            }
            (function(){
              const MIN_INTERVAL_MS = 3000;
              let last = 0;
              const _show = showSpeedLimitPopup;
              window.showSpeedLimitPopup = function(cam){
                const now = Date.now();
                if (now - last < MIN_INTERVAL_MS) return; // skip
                last = now;
                _show?.(cam);
              };
            })();
            (function(){
              const MIN_MS = 3000; let last = 0;
              const _show = showSpeedSign;
              window.showSpeedSign = function(limit){
                const now = Date.now(); if (now - last < MIN_MS) return;
                last = now; _show?.(limit);
              };
            })();
            /* -------- helper to read speedLimit only if present -------- */
            function getCameraSpeedLimit(cam){
              const v = cam?.speedLimit ?? cam?.properties?.speedLimit;
              const n = (typeof v === "string") ? parseFloat(v) : v;
              return (Number.isFinite(n)) ? Math.round(n) : null;
            }
            /* -------- Leaflet resize fix (ensure map isn’t clipped under UI changes) -------- */
            (function(){
              let _timer = null;
              const kick = ()=>{ clearTimeout(_timer); _timer = setTimeout(()=> map?.invalidateSize?.(), 150); };
              window.addEventListener('resize', kick);
              window.addEventListener('orientationchange', kick);
              // if you open/close panels that change layout, call kick() after the transition
              window.mapKickResize = kick;
            })();
            /* -------- Testing hooks (inspect nearest + internal config from console) -------- */
            (function(){
              window.getNearestForDebug = function(lat,lng){
                const pos = { coords: { latitude: lat, longitude: lng } };
                const feats = (window.CAMERAS_GEOJSON||{}).features||[];
                if (window.findNearestCameraFast) return window.findNearestCameraFast(pos, feats);
            
                // simple linear fallback without Turf:
                let best = { feature:null, distM: Infinity, idx:-1 };
                for (let i=0; i<feats.length; i++){
                  const f = feats[i];
                  const [lng, lat] = f.geometry?.coordinates || [];
                  if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
                  const d = distKm(lat, lng, pos.coords.latitude, pos.coords.longitude) * 1000;
                  if (d < best.distM) best = { feature:f, distM:d, idx:i };
                }
                return best;
              };
              window.alertConfig = function(){ return {
                // present if SNIPPET 15 loaded:
                pro: typeof window.shouldAlertCameraPro === 'function',
                stateSize: window.__alertState?.().size
              }};
            })();
            window.announce = (msg)=>{ const n=document.getElementById('ariaLive'); if(n) n.textContent=String(msg||''); };
            /* -------- Start everything -------- */
            initMap();
            loadCamerasAndStart({ autoStart: false, drawPoles: false });
            let cameras = [];
            let dataReadyResolve;
            const dataReady = new Promise(res => (dataReadyResolve = res));
            // helper: normalize all poles to [lng, lat] + clean props
            function normalizePolesFC(polesFC){
              const raw = (polesFC && polesFC.type === 'FeatureCollection')
                ? polesFC
                : { type: 'FeatureCollection', features: Array.isArray(polesFC) ? polesFC : [] };
              const features = (raw.features || []).map((f, i) => {
                const g = f?.geometry || {};
                let coords = g.coordinates;
                if (!coords || coords.length !== 2) return null;
                const [a,b] = coords;
                const looksLatLng = Math.abs(a) <= 90 && Math.abs(b) <= 180;
                const looksLngLat = Math.abs(a) <= 180 && Math.abs(b) <= 90;
                if (looksLatLng && !looksLngLat) coords = [b, a]; // flip -> [lng, lat]
                const p = f.properties || {};
                const id = p.id ?? p.pole_id ?? p.name ?? f.id ?? `cam_${i}`;
                const facing = String(p.direction ?? p.facing ?? 'BOTH').toUpperCase();
                const speedLimit = getCameraSpeedLimit({ properties: p }); // your helper
                return {
                  type: 'Feature',
                  id,
                  properties: { ...p, id, facing, speedLimit },
                  geometry: { type: 'Point', coordinates: coords }
                };
              }).filter(Boolean);
              return { type: 'FeatureCollection', features };
            }
            (async () => {
                try {
                    const [corrRaw, polesRaw] = await Promise.all([fetchJSON(CORRIDORS_URL), fetchJSON(POLES_URL)]);
                    const corrPolysFC = normalizeToPolygons(corrRaw || { type:'FeatureCollection', features: [] });
                    // ✅ normalize once; use everywhere
                    const polesFC = normalizePolesFC(polesRaw);
                    // build the simple array used by the geofence loop
                    cameras = (polesFC.features || []).map(f => {
                      const [lng, lat] = f.geometry.coordinates;
                      return {
                        name: f.properties?.name || 'Speed Camera',
                        lat, lon: lng,
                        direction: (f.properties?.facing || 'BOTH').toUpperCase(),
                        pole_id: f.properties?.pole_id
                      };
                    });
                    const { fc: corr33, corridorForPole } = filterCorridorsToPoles(corrPolysFC, polesFC);
                    addCorridors(corr33);
                    addPoleMarkers(polesFC, corridorForPole); // ← use normalized FC
                    showDebug(`Corridors: ${(corr33.features||[]).length} • Poles: ${(polesFC.features||[]).length}`);
                    // publish normalized data + rebuild KD-tree
                    window.CAMERAS_GEOJSON = polesFC;
                    if (HAS.kdb && window.buildCameraIndex) window.buildCameraIndex(polesFC.features);
                    await loadSpeedLimits();
                    dataReadyResolve();
                } catch (e) {
                    dataReadyResolve();
                }
                await window.audioManifestReady;
                setTimeout(() => { preloadAudioList(buildAudioUrls(), isMobile ? 2 : 3); }, 300);
            })();
            addEventListener('pagehide', () => {
              try { window.stopGPS?.(); } catch(_) {}
              try { clearInterval(window.nagInt || 0); } catch(_) {}
            }, { once: true });
            // --- App mode: single source of truth + safe early call ---
            window.mode = window.mode || 'off';
            window.applyMode = function(){
              const btn = document.getElementById('warmup'); // may not exist yet; that's OK
              btn?.classList.remove('btn-off','btn-on','btn-mute');
              btn?.setAttribute('aria-pressed', String(window.mode==='on'));
            
              if (window.mode === 'off') {
                btn?.classList.add('btn-off');
                if (btn) btn.textContent = 'Sound & GPS: Off';
                window.stopGPS?.();
              } else if (window.mode === 'on') {
                btn?.classList.add('btn-on');
                if (btn) btn.textContent = 'Sound & GPS: On';
                window.startGPS?.();      // safe: optional chaining until startGPS is defined
              } else { // 'mute'
                btn?.classList.add('btn-mute');
                if (btn) btn.textContent = 'Mute: GPS Only';
                window.startGPS?.();
              }
            };
            window.applyMode();
            /* -------- Warmup button -------- */
            const warmBtn = document.getElementById('warmup');
            const testBtn = document.getElementById('testSound');
            let preloaded = false;
            warmBtn.addEventListener('click', async () => {
              const next = (window.mode==='off') ? 'on' : (window.mode==='on' ? 'mute' : 'off');
            
              const proceed = () => {
                window.mode = next;
                window.applyMode();
                (async () => {
                  try {
                    await AudioUnlock.unlock();
                    if (!preloaded){ preloaded=true; setTimeout(()=>preloadAudioList(buildAudioUrls(), isMobile?2:3), 150); }
                  } catch (e) { if (DEV) console.error('Unlock failed on button:', e); }
                })();
              };
            
              if (window.mode === 'off' && (next === 'on' || next === 'mute') && !termsAccepted()) {
                showTermsModal(proceed);
                return;
              }
              proceed();
            });
            if (DEV && testBtn) testBtn.style.display = '';
            testBtn?.addEventListener('click', async ()=>{
                if (!window.AUDIO_BASE) return;
                await audioManifestReady;
                await ensureAudioReady();
                await playNow(`${AUDIO_BASE}speed_camera_ahead_1.mp3`);
                await playNow(`${AUDIO_BASE}${pick(TAGS)}`);
            });
            /* -------- Onboarding / PWA nudges -------- */
            function ckSet(k, v, days = 7) {
                try {
                    const d = new Date(Date.now() + days * 864e5);
                    document.cookie = `${encodeURIComponent(k)}=${encodeURIComponent(v)}; path=/; expires=${d.toUTCString()}`;
                } catch {}
            }
            function ckGet(k) {
                try {
                    return document.cookie.split('; ').map(s => s.split('=')).reduce((a, [kk, v]) => (a[decodeURIComponent(kk)] = decodeURIComponent(v || ''), a), {})[k] || null;
                } catch { return null; }
            }
            function lsSet(k, v) {
                try { localStorage.setItem(k, v); return true; } catch { ckSet(k, v); return false; }
            }
            function lsGet(k) {
                try { const v = localStorage.getItem(k); return v == null ? ckGet(k) : v; } catch { return ckGet(k); }
            }
            // --- Terms gating (versioned) ---
            const TERMS_VER = "2025-01-18";     // bump when Terms text changes
            const TERMS_KEY = "terms_accept_v1";
            
            function termsAccepted() {
              const raw = (typeof lsGet === 'function') ? lsGet(TERMS_KEY) : null;
              if (!raw) return false;
              try { const { ver } = JSON.parse(raw); return ver === TERMS_VER; } catch { return false; }
            }
            
            function showTermsModal(onAccept) {
              const el = document.getElementById('termsModal');
              if (!el) { onAccept?.(); return; }
            
              document.getElementById('termsVersionLabel')?.replaceChildren(document.createTextNode(TERMS_VER));
            
              // Wire once
              if (!el.dataset.wired) {
                const ack1 = document.getElementById('ackNotDriving');
                const ack2 = document.getElementById('ackAgree');
                const btn  = document.getElementById('termsAccept');
                const enable = () => { btn.disabled = !(ack1?.checked && ack2?.checked); };
                ack1?.addEventListener('change', enable);
                ack2?.addEventListener('change', enable);
                enable(); // set initial state
                btn?.addEventListener('click', () => {
                  (typeof lsSet === 'function') && lsSet(TERMS_KEY, JSON.stringify({ ver: TERMS_VER, ts: Date.now() }));
                  bootstrap.Modal.getInstance(el)?.hide();
                  onAccept?.();
                }, { once: true });
                el.dataset.wired = '1';
              }
            
              const modal = bootstrap.Modal.getOrCreateInstance(el, { backdrop: 'static', keyboard: false });
              modal.show();
            }
            const ONBOARD_KEY = 'onboard_privacy_v1';
            const PWA_DONE_KEY = 'pwa_installed_v1';
            const PWA_LATER_KEY = 'pwa_install_later_ts';
            const THREE_DAYS = 3 * 24 * 60 * 60 * 1000;
            const privacyToastEl = document.getElementById('privacyToast');
            const installToastEl = document.getElementById('installToast');
            const privacyToast = privacyToastEl ? new bootstrap.Toast(privacyToastEl) : null;
            const installToast = installToastEl ? new bootstrap.Toast(installToastEl) : null;
            const privacyEnableBtn = document.getElementById('privacyEnable');
            const privacyLaterBtn = document.getElementById('privacyLater');
            const privacyConfirmEl = document.getElementById('privacyConfirm');
            const privacyLink = document.getElementById('privacyLink');
            const privacyFallback = document.getElementById('privacyFallback');
            if (privacyLink) {
                privacyLink.addEventListener('click', (e) => {
                    fetch(privacyLink.href, { method: 'HEAD' }).catch(() => {
                        e.preventDefault();
                        privacyFallback?.classList.remove('d-none');
                    });
                });
            }
            function showPrivacyModalIfNeeded() {
              const privacyModalEl = document.getElementById('privacyModal');
              if (!privacyModalEl || lsGet(ONBOARD_KEY)) return;
            
              const modal = new bootstrap.Modal(privacyModalEl, { backdrop: 'static', keyboard: false });
              modal.show();
            
              privacyEnableBtn?.addEventListener('click', async () => {
                try { await AudioUnlock.unlock(); } catch {}
            
                const go = () => document.getElementById('warmup')?.click();
                if (termsAccepted()) go(); else showTermsModal(go);
            
                lsSet(ONBOARD_KEY, '1');
                privacyConfirmEl?.classList.remove('d-none');
            
                setTimeout(() => {
                  modal.hide();
                  promptPWAInstall();
                  maybeShowInstallNudgeSoon();
                }, 600);
              }, { once: true });
            
              privacyLaterBtn?.addEventListener('click', () => {
                modal.hide();
                setTimeout(() => privacyToast?.show(), 3000);
              }, { once: true });
            }
            document.getElementById('toastEnable')?.addEventListener('click', () => {
                privacyToast?.hide();
                showPrivacyModalIfNeeded();
            });
            document.getElementById('toastLater')?.addEventListener('click', () => privacyToast?.hide());
            let deferredPrompt = null;
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
            });
            document.getElementById('iosGuideImg')?.addEventListener('error', e => { e.currentTarget.classList.add('d-none'); });
            async function promptPWAInstall() {
                const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const choice = await deferredPrompt.userChoice.catch(() => ({ outcome: 'dismissed' }));
                    if (choice?.outcome === 'accepted') lsSet(PWA_DONE_KEY, '1');
                    deferredPrompt = null;
                    return;
                }
                if (isIOS) {
                    const iosEl = document.getElementById('iosInstall');
                    if (iosEl) {
                        const m = new bootstrap.Modal(iosEl, { backdrop: 'static', keyboard: false });
                        m.show();
                        document.getElementById('iosDone')
                            ?.addEventListener('click', () => lsSet(PWA_DONE_KEY, '1'), { once: true });
                        document.getElementById('iosClose')?.addEventListener('click', () => lsSet(PWA_LATER_KEY, String(Date.now())), { once: true });
                    }
                    return;
                }
                lsSet(PWA_LATER_KEY, String(Date.now()));
            }
            function shouldRemindInstall() {
                if (lsGet(PWA_DONE_KEY)) return false;
                const isStandalone =
                  (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
                  (navigator && navigator.standalone === true);
                if (isStandalone) return false;
                const later = parseInt(lsGet(PWA_LATER_KEY) || '0', 10);
                return !later || (Date.now() - later) > THREE_DAYS;
            }
            function maybeShowInstallNudgeSoon() {
                if (shouldRemindInstall()) setTimeout(() => installToast?.show(), 10000);
            }
            document.getElementById('toastInstall')?.addEventListener('click', async () => {
                installToast?.hide();
                await promptPWAInstall();
            });
            document.getElementById('toastInstallLater')?.addEventListener('click', () => {
                installToast?.hide();
                lsSet(PWA_LATER_KEY, String(Date.now()));
            });
            if (lsGet(ONBOARD_KEY)) {
                setTimeout(maybeShowInstallNudgeSoon, 5000);
            } else {
                showPrivacyModalIfNeeded();
            }
            /* -------- Audio lists (stems/tags/locations) -------- */
            const AUDIO_BASE = `${BASE}/images/audio/`;
            async function ensureAudioReady(){
                try{
                    await AudioUnlock.unlock();
                    const ctx = AudioUnlock.ctx;
                    if (ctx && ctx.state === 'suspended') {
                        await ctx.resume();
                    }
                }catch{}
            }
            window.addEventListener('touchend', () => AudioUnlock.unlock(), { once:true, passive:true });
            let player = new Audio();
            function isStandalone(){
                return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator && navigator.standalone === true);
            }
            async function playNow(url){
                if (window.mode !== 'on') return;
                if (document.visibilityState !== 'visible' && !isStandalone()) {
                    if (DEV) console.warn('Audio blocked: page hidden');
                    return;
                }
                await ensureAudioReady();
                const u = url + (DEV ? ((url.includes('?')?'&':'?')+'v='+Date.now()) : '');
                return new Promise((resolve) => {
                    try { player.pause(); } catch {}
                    player = new Audio(u);
                    player.muted = false;
                    player.preload = 'auto';
                    player.crossOrigin = 'anonymous';
                    player.playsInline = true;
                    let watchdogTO;
                    const armWatchdog = () => {
                        const ms = Math.min(30000, Math.max(15000, Number.isFinite(player.duration) ? (player.duration + 0.25) * 1000 : 15000 ));
                        clearTimeout(watchdogTO);
                        watchdogTO = setTimeout(() => {
                            if (DEV) console.warn('Audio watchdog elapsed for', u.split('/').pop());
                            resolve();
                        }, ms);
                    };
                    player.onloadedmetadata = armWatchdog;
                    player.onended = () => {
                        clearTimeout(watchdogTO);
                        resolve();
                    };
                    player.onerror = () => {
                        clearTimeout(watchdogTO);
                        if (DEV) console.error('Audio error:', u);
                        resolve();
                    };
                    armWatchdog();
                    player.play().catch(err => {
                        if (DEV) console.error('play() rejected:', err);
                        clearTimeout(watchdogTO);
                        resolve();
                    });
                });
            }
            const STEMS = Array.from({length:11},(_,i)=>`speed_camera_ahead_${i+1}.mp3`);
            const TAGS = [
                'your_wallet_just_got_a_little_nervous.mp3',
                'your_best_pose_is_slow.mp3',
                'your_brakes_called_they_are_ready_to_help.mp3',
                'Your_future_self_says_thanks.mp3',
                'they_go_high_we_go_slow.mp3',
                'the_only_rush_is_in_your_head.mp3',
                'the_smart_money_is_on_slowing_down.mp3',
                'this_picture_is_not_for_the_gram.mp3',
                'slow_and_easy_hotshot.mp3',
                'slow_is_the_new_fast.mp3',
                'save_the_drama_for_the_drivethru.mp3',
                'pace_yourself.mp3',
                'no_rush_no_fuss.mp3',
                'no_need_for_a_photo_finish.mp3',
                'less_gas_more_class.mp3',
                'give_those_brakes_a_little_love.mp3',
                'easy_does_it.mp3',
                'drive_like_someone_is_watching.mp3',
                'brakes_are_a_good_good_friend.mp3'
            ];
            const LOC = {
                "Fulton Street from 42nd to 43rd Ave":"fulton_street_from_42nd_to_43rd_ave.mp3",
                "Lincoln Way from 27th to 28th Ave":"lincoln_way_from_27th_to_28th_ave.mp3",
                "Geary Blvd from 7th to 8th Ave":"geary_blvd_from_7th_to_8th_ave.mp3",
                "Fulton St from 2nd Ave to Arguello Blvd":"fulton_st_from_2nd_ave_to_arguello_blvd.mp3",
                "Geary Blvd from Webster to Buchanan St":"geary_blvd_from_webster_to_buchanan_st.mp3",
                "Turk St from Van Ness Ave to Polk St":"turk_st_from_van_ness_ave_to_polk_st.mp3",
                "Bay St from Octavia to Gough St":"bay_st_from_octavia_to_gough_st.mp3",
                "Franklin St from Union to Green St":"franklin_st_from_union_to_green_st.mp3",
                "Columbus Ave from Lombard to Greenwich St":"columbus_ave_from_lombard_to_greenwich_st.mp3",
                "Broadway from Powell to Stockton St":"broadway_from_powell_to_stockton_st.mp3",
                "The Embarcadero from Green to Battery St":"the_embarcadero_from_green_to_battery_st.mp3",
                "Mission St from 8th to 9th St":"mission_st_from_8th_to_9th_st.mp3",
                "10th St from Harrison to Folsom St":"10th_st_from_harrison_to_folsom_st.mp3",
                "9th St from Bryant to Harrison St":"9th_st_from_bryant_to_harrison_st.mp3",
                "7th St from Harrison to Folsom St":"7th_st_from_harrison_to_folsom_st.mp3",
                "Harrison St from 4th to 5th St":"harrison_st_from_4th_to_5th_st.mp3",
                "Bryant St from 2nd to 3rd St":"bryant_st_from_2nd_to_3rd_st.mp3",
                "King St (EB only) from 4th to 5th St":"king_st_eb_only_from_4th_to_5th_st.mp3",
                "Market St from Danvers to Douglass St":"market_st_from_danvers_to_douglass_st.mp3",
                "Guerrero St from 19th to 20th St":"guerrero_st_from_19th_to_20th_st.mp3",
                "16th St from Bryant St to Potrero Ave":"16th_st_from_bryant_st_to_potrero_ave.mp3",
                "San Jose Ave from 29th to 30th St":"san_jose_ave_from_29th_to_30th_st.mp3",
                "Cesar Chavez St from Folsom to Harrison St":"cesar_chavez_st_from_folsom_to_harrison_st.mp3",
                "Cesar Chavez St from Indiana to Tennessee St":"cesar_chavez_st_from_indiana_to_tennessee_st.mp3",
                "3rd St (NB only) from Key to Jamestown Ave":"3rd_st_nb_only_from_key_to_jamestown_ave.mp3",
                "Bayshore Blvd (SB only) from 101 off-ramp to Tunnel Ave":"bayshore_blvd_sb_only_from_101_off_ramp_to_tunnel_ave.mp3",
                "Geneva Ave from Prague St to Brookdale Ave":"geneva_ave_from_prague_st_to_brookdale_ave.mp3",
                "Mission St from Ottawa Ave to Allison St":"mission_st_from_ottawa_ave_to_allison_st.mp3",
                "Alemany Blvd from Farragut to Naglee Ave":"alemany_blvd_from_farragut_to_naglee_ave.mp3",
                "Ocean Ave from Frida Kahlo Way to Howth St":"ocean_ave_from_frida_kahlo_way_to_howth_st.mp3",
                "San Jose Ave from Santa Ynez to Ocean Ave":"san_jose_ave_from_santa_ynez_to_ocean_ave.mp3",
                "Monterey Blvd from Edna to Congo St":"monterey_blvd_from_edna_to_congo_st.mp3",
                "Sloat Blvd from 41st Ave to Skyline Blvd":"sloat_blvd_from_41st_ave_to_skyline_blvd.mp3"
            };
            // ---- Self-healing audio manifest (prune 404s) ----
            async function urlExists(url){
                try {
                    let r = await fetch(url, { method:'HEAD', cache:'no-store' });
                    if (r.ok) return true;
                    if (r.status === 405) {
                        r = await fetch(url, { method:'GET', cache:'no-store' });
                        return r.ok;
                    }
                    return false;
                } catch { return false; }
            }
            async function pruneMissingAudio(){
                const okStems = [];
                for (const s of STEMS){
                    const u = `${AUDIO_BASE}${s}`;
                    if (await urlExists(u)) okStems.push(s);
                }
                STEMS.length = 0; STEMS.push(...okStems);
                const okTags = [];
                for (const t of TAGS){
                    const u = `${AUDIO_BASE}${t}`;
                    if (await urlExists(u)) okTags.push(t);
                }
                TAGS.length = 0; TAGS.push(...okTags);
                const okLoc = {};
                for (const [k,f] of Object.entries(LOC)){
                    const u = `${AUDIO_BASE}${f}`;
                    if (await urlExists(u)) okLoc[k]=f;
                }
                for (const k of Object.keys(LOC)) delete LOC[k];
                Object.assign(LOC, okLoc);
                if (DEV) console.info('[DEV] audio manifest:', { stems: STEMS.length, tags: TAGS.length, locs: Object.keys(LOC).length });
            }
            const audioManifestReady = (window.audioManifestReady = pruneMissingAudio());
            function pick(a){return a[Math.floor(Math.random()*a.length)]}
            function playLocationOnly(name){
                const f=LOC[name];
                if(f) playNow(`${AUDIO_BASE}${f}`);
            }
            /* -------- Trial Nag (audio-synced close + caps) -------- */
            const NAG_FIRST_MS = 120000;
            const NAG_REPEAT_MS = 15*60*1000;
            const NAG_IMAGES = [`${BASE}/images/Ad1.png`, `${BASE}/images/Ad2.png`];
            const NAG_AUDIO_URL = `${BASE}/images/audio/Ad1.mp3`;
            const nagEl = document.getElementById('nag');
            const nagImg = document.getElementById('nagImg');
            const nagCount = document.getElementById('nagCountdown');
            const nagAudio = new Audio(NAG_AUDIO_URL);
            nagAudio.preload = 'auto';
            nagAudio.crossOrigin = 'anonymous';
            const NAG_MAX_VISIBLE_MS_AUDIO = DEV ? 2000 : 4500;
            const NAG_MAX_VISIBLE_MS_SILENT = DEV ? 1500 : 2500;
            let nagPlaying = false, nagBuffer = null, nagBufferReady = false, lastActive = null;
            function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
            function focusTrapOn(){ nagEl?.setAttribute('aria-hidden','false'); }
            function focusTrapOff(){ nagEl?.setAttribute('aria-hidden','true'); }
            async function ensureNagBuffer(){
                if (nagBufferReady) return nagBuffer;
                try{
                    const res = await fetch(`${NAG_AUDIO_URL}?v=${Date.now()}`, { cache:'force-cache' });
                    const ab = await res.arrayBuffer();
                    await AudioUnlock.unlock();
                    const ctx = AudioUnlock.ctx;
                    nagBuffer = await ctx.decodeAudioData(ab).catch(()=>null);
                    nagBufferReady = true;
                }catch(e){ nagBufferReady = false; }
                return nagBuffer;
            }
            async function playNagWebAudio(){
                const buf = await ensureNagBuffer();
                if (!buf) throw new Error('no-buffer');
                const ctx = AudioUnlock.ctx;
                return new Promise(resolve=>{
                    const src = ctx.createBufferSource();
                    src.buffer = buf;
                    src.connect(ctx.destination);
                    src.onended = resolve;
                    try { src.start(0); } catch { resolve(); }
                });
            }
            async function playNagAudioFallback(){
                await AudioUnlock.unlock();
                try { nagAudio.pause(); } catch {}
                try {
                    nagAudio.currentTime = 0;
                    nagAudio.load();
                    await nagAudio.play();
                } catch {
                    await sleep(300);
                    try { await nagAudio.play(); } catch {}
                }
            }
            async function showNag(){
                if (nagPlaying) return;
                nagPlaying = true;
                const audioAllowed = (window.mode === 'on');
                lastActive = document.activeElement;
                if (nagImg) nagImg.src = NAG_IMAGES[Math.floor(Math.random()*NAG_IMAGES.length)];
                if (nagEl) {
                    nagEl.style.display = 'flex';
                    nagEl.tabIndex = -1;
                    nagEl.focus();
                    focusTrapOn();
                    const onKey = (e)=>{ if (e.key === 'Escape') { e.stopPropagation(); safeClose(); } };
                    nagEl.addEventListener('keydown', onKey, { once:true });
                }
                const safeClose = () => {
                    try { nagAudio.pause(); nagAudio.currentTime = 0; } catch {}
                    if (nagEl && nagEl.style.display === 'flex') {
                        nagEl.style.display = 'none';
                        focusTrapOff();
                        lastActive?.focus?.();
                    }
                    nagPlaying = false;
                };
                try {
                    if (audioAllowed) {
                        await ensureAudioReady();
                        let t = 3; nagCount.textContent = t;
                        const iv = setInterval(()=>{ if(--t<=0){clearInterval(iv);} nagCount.textContent = t; }, 1000);
                        let watchdog = setTimeout(safeClose, 12000);
                        try {
                            await playNagWebAudio();
                        } catch {
                            await playNagAudioFallback();
                            await new Promise(r => { nagAudio.addEventListener('ended', r, { once: true }); });
                        }
                        clearTimeout(watchdog);
                        safeClose();
                    } else {
                        setTimeout(safeClose, NAG_MAX_VISIBLE_MS_SILENT);
                    }
                } catch { safeClose(); }
            }
            setTimeout(() => { if (!document.hidden) showNag(); }, NAG_FIRST_MS);
            let nagInt = window.nagInt || null;
            function armNagInterval() {
                clearInterval(window.nagInt || nagInt);
                nagInt = window.nagInt = setInterval(() => { if (!document.hidden) showNag(); }, NAG_REPEAT_MS);
            }
            document.addEventListener('visibilitychange', armNagInterval, { passive: true });
            armNagInterval();
            /* -------- Geofence alert chain (instant start) -------- */
            const PREARM_EXTRA_M = 0; // keep 0 unless you want a fixed extra radius
            function headingIsOk(heading, uLat, uLon, cLat, cLon, dir){
                // If device heading unavailable, don't block
                if (typeof heading !== 'number' || !isFinite(heading)) return true;
                // Vector from user -> camera
                const dy = (cLat - uLat), dx = (cLon - uLon);
                const bearing = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                const diff = Math.min(Math.abs(bearing - heading), 360 - Math.abs(bearing - heading));
                const facing = diff <= 100; // generous cone
                if (dir === 'BOTH') return facing;
                if (dir === 'NB' || dir === 'SB' || dir === 'EB' || dir === 'WB') {
                    // If you later annotate corridor headings, add checks here
                    return facing;
                }
                return facing;
            }
            async function playGeofenceAlert(name) {
                showSpeedSign(SPEED_LIMITS[name]);
                try { await ensureAudioReady(); } catch {}
                (async () => {
                    try {
                        await audioManifestReady;
                        await ensureAudioReady();
                        if (window.mode === 'mute') return;
                        const f = LOC[name];
                        const seq = [
                            `${AUDIO_BASE}${pick(STEMS)}`,
                            f ? `${AUDIO_BASE}${f}` : null,
                            `${AUDIO_BASE}${pick(TAGS)}`
                        ].filter(Boolean);
                        await new Promise(r => setTimeout(r, 110));
                        for (const url of seq) {
                            await playNow(url);
                        }
                    } catch (e) {
                        if (DEV) console.warn('Alert seq error', e);
                    }
                })();
                if (navigator.vibrate) navigator.vibrate([250, 100, 250]);
            }
            /* -------- Speed limits loader -------- */
            const SPEED_LIMITS = {};
            const SPEEDS_URL = `${DATA_BASE}/camera_speed_limits.json`;
            function canonicalize(n) {
                return String(n).toLowerCase()
                    .replace(/\([^)]*\)/g, ' ')
                    .replace(/[ ,]/g, ' ')
                    .replace(/\bfrom\b|\bto\b/g, ' ')
                    .replace(/^\s*the\s+/i, '')
                    .replace(/\b(street|st|avenue|ave|boulevard|blvd|road|rd|drive|dr|way)\b/gi, '')
                    .replace(/-/g, ' ')
                    .replace(/\s+/g, ' ').trim();
            }
            async function loadSpeedLimits() {
                try {
                    const rows = await fetchJSON(SPEEDS_URL);
                    const canon = new Map(rows.map(r => [canonicalize(r.name), +r.speedLimit]));
                    for (const c of cameras) {
                        const hit = canon.get(canonicalize(c.name));
                        if (Number.isFinite(hit)) SPEED_LIMITS[c.name] = hit;
                    }
                    const missing = cameras.filter(c => SPEED_LIMITS[c.name] === undefined).map(c => c.name);
                    if (missing.length) console.warn('No speed limit for:', missing);
                } catch (e) { /* file may not exist; ignore */ }
            }
            function buildAudioUrls() {
                const urls = [];
                urls.push(`${AUDIO_BASE}beep.mp3`);
                for (const s of STEMS) urls.push(`${AUDIO_BASE}${s}`);
                for (const t of TAGS) urls.push(`${AUDIO_BASE}${t}`);
                Object.values(LOC).forEach(f => urls.push(`${AUDIO_BASE}${f}`));
                return urls;
            }
            async function preloadAudioList(urls, concurrency = 3) {
                const queue = [...urls];
                const workers = Array.from({ length: concurrency }, async () => {
                    while (queue.length) {
                        const url = queue.shift();
                        try {
                            const a = new Audio();
                            a.preload = 'auto';
                            a.src = url;
                            a.load();
                            await new Promise(r => {
                                a.oncanplaythrough = () => r();
                                setTimeout(r, 1200);
                            });
                        } catch (e) {}
                    }
                });
                await Promise.all(workers);
            }
            /* -------- isInsideAnyCorridor + start/stop GPS -------- */
            function isInsideAnyCorridor(lat, lon){
              if (!window.turf?.booleanPointInPolygon) return false;
              try{
                const pt = turf.point([lon, lat]);
                return corridorPolys.some(poly => {
                  try { return turf.booleanPointInPolygon(pt, poly); } catch { return false; }
                });
              }catch{ return false; }
            }
            const EXIT_M = 150;
            const HYSTERESIS_M = 20;
            const MIN_SPEED_MPS = 2.2;
            const COOLDOWN_MS = 10000;
            const REARM_M = DEV ? 50 : 100;
            function enterDistanceM(speedMps){
                const v = Number.isFinite(speedMps) && speedMps > 0 ? speedMps : 24.6; // ~55 mph fallback
                return Math.max(250, Math.min(700, Math.round(v * 18)));
            }
            const insideNow = new Set(), lastAlertAt = new Map();
            const lastAlertPos = new Map();
            function distM(aLat,aLon,bLat,bLon){ return distKm(aLat,aLon,bLat,bLon)*1000; }
            function markAlert(name, lat, lon){
                lastAlertAt.set(name, Date.now());
                lastAlertPos.set(name, { lat, lon });
            }
            function passesGates(coords){
                const {accuracy,speed}=coords;
                if(!DEV && accuracy && accuracy>ACCURACY_MAX_M) return false;
                if(!DEV && typeof speed==='number' && speed<MIN_SPEED_MPS) return false;
                return true;
            }
            async function startGPS(){
                if (!termsAccepted()) { showTermsModal(()=> startGPS()); return; }
                if(!('geolocation' in navigator)) return;
                if(window.__watchId!=null) return;
                await dataReady;
                if (!map.hasLayer(userMarker)) userMarker.addTo(map);
                window.__watchId = navigator.geolocation.watchPosition(async pos=>{
                    const {latitude,longitude} = pos.coords;
                    userMarker.setLatLng([latitude, longitude]);
                    if(!passesGates(pos.coords)) {
                        if (DEV) console.debug('[DEV] gates blocked', { acc: Math.round((pos.coords.accuracy??0)*10)/10, spd: Math.round((pos.coords.speed??0)*10)/10, lat: +(latitude.toFixed(3)), lon: +(longitude.toFixed(3)) });
                        return;
                    }
                    const inCorridor = isInsideAnyCorridor(latitude, longitude);
                    const nearestName = nearestCameraName(latitude, longitude);
                    const now=Date.now();
                    for(const cam of cameras){
                        const dM = distKm(latitude, longitude, cam.lat, cam.lon)*1000;
                        const nearPoint = dM <= Math.max(enterDistanceM(pos.coords.speed), PREARM_EXTRA_M);
                        const corridorMatch = inCorridor && (nearestName === cam.name);
                        const headingOk = headingIsOk(pos.coords.heading, latitude, longitude, cam.lat, cam.lon, cam.direction);
                        const inZone = headingOk && (nearPoint || corridorMatch);
                        const wasIn = insideNow.has(cam.name);
                        const movedEnough = (() => {
                            const p = lastAlertPos.get(cam.name);
                            return p ? (distM(latitude, longitude, p.lat, p.lon) > REARM_M) : true;
                        })();
                        if(!wasIn && inZone){
                            const last = lastAlertAt.get(cam.name)||0;
                            if(now-last>COOLDOWN_MS && movedEnough){
                                if (DEV) console.debug('[DEV] alert ->', cam.name);
                                await ensureAudioReady();
                                playGeofenceAlert(cam.name);
                                markAlert(cam.name, latitude, longitude);
                            } else if (DEV) {
                                const p = lastAlertPos.get(cam.name);
                                const moved = p ? Math.round(distM(latitude, longitude, p.lat, p.lon)) : 'n/a';
                                console.debug('[DEV] suppressed', cam.name, { cooldown: now-last, moved });
                            }
                            insideNow.add(cam.name);
                        } else if (wasIn && !inZone && dM > (EXIT_M + HYSTERESIS_M)){
                            insideNow.delete(cam.name);
                            hideSpeedSign();
                        }
                    }
                }, err=>console.warn('Geolocation error', err), { enableHighAccuracy:true, maximumAge:500, timeout:8000 });
            }
            function stopGPS(){
                if (window.__watchId!=null){
                    navigator.geolocation.clearWatch(window.__watchId);
                    window.__watchId=null;
                }
                try{ map.removeLayer(userMarker); }catch{}
                insideNow.clear();
                hideSpeedSign();
            }
            window.startGPS = startGPS;
            window.stopGPS = stopGPS;
        });
    </script>
</body>
</html>
